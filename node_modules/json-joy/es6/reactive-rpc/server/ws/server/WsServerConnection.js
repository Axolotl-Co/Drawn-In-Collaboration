"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsServerConnection = void 0;
const tslib_1 = require("tslib");
const crypto = tslib_1.__importStar(require("crypto"));
const codec_1 = require("../codec");
const utf8_1 = require("../../../../util/strings/utf8");
const concat_1 = require("../../../../util/buffers/concat");
class WsServerConnection {
    constructor(encoder, socket) {
        this.encoder = encoder;
        this.socket = socket;
        this.closed = false;
        this.maxIncomingMessage = 2 * 1024 * 1024;
        this.maxBackpressure = 2 * 1024 * 1024;
        this.defaultOnPing = (data) => {
            this.sendPong(data);
        };
        this._fragments = [];
        this._fragmentsSize = 0;
        this.defaultOnFragment = (isLast, data, isUtf8) => {
            const fragments = this._fragments;
            this._fragmentsSize += data.length;
            if (this._fragmentsSize > this.maxIncomingMessage) {
                this.onClose(1009, 'TOO_LARGE');
                return;
            }
            fragments.push(data);
            if (!isLast)
                return;
            this._fragments = [];
            this._fragmentsSize = 0;
            const message = (0, concat_1.listToUint8)(fragments);
            this.onmessage(message, isUtf8);
        };
        this.onmessage = () => { };
        this.onfragment = this.defaultOnFragment;
        this.onping = this.defaultOnPing;
        this.onpong = () => { };
        this.onclose = () => { };
        this.__buffer = [];
        this.__writeTimer = null;
        const decoder = new codec_1.WsFrameDecoder();
        let currentFrameHeader = null;
        let fragmentStartFrameHeader = null;
        const handleData = (data) => {
            try {
                decoder.push(data);
                main: while (true) {
                    if (currentFrameHeader instanceof codec_1.WsFrameHeader) {
                        const length = currentFrameHeader.length;
                        if (length > this.maxIncomingMessage) {
                            this.onClose(1009, 'TOO_LARGE');
                            return;
                        }
                        if (length <= decoder.reader.size()) {
                            const buf = new Uint8Array(length);
                            decoder.copyFrameData(currentFrameHeader, buf, 0);
                            if (fragmentStartFrameHeader instanceof codec_1.WsFrameHeader) {
                                const isText = fragmentStartFrameHeader.opcode === 1;
                                const isLast = currentFrameHeader.fin === 1;
                                currentFrameHeader = null;
                                if (isLast)
                                    fragmentStartFrameHeader = null;
                                this.onfragment(isLast, buf, isText);
                            }
                            else {
                                const isText = currentFrameHeader.opcode === 1;
                                currentFrameHeader = null;
                                this.onmessage(buf, isText);
                            }
                        }
                        else
                            break;
                    }
                    const frame = decoder.readFrameHeader();
                    if (!frame)
                        break;
                    if (frame instanceof codec_1.WsPingFrame) {
                        this.onping(frame.data);
                        continue main;
                    }
                    if (frame instanceof codec_1.WsPongFrame) {
                        this.onpong(frame.data);
                        continue main;
                    }
                    if (frame instanceof codec_1.WsCloseFrame) {
                        decoder.readCloseFrameData(frame);
                        this.onClose(frame.code, frame.reason);
                        continue main;
                    }
                    if (frame instanceof codec_1.WsFrameHeader) {
                        if (fragmentStartFrameHeader) {
                            if (frame.opcode !== 0) {
                                this.onClose(1002, 'DATA');
                                return;
                            }
                            currentFrameHeader = frame;
                        }
                        if (frame.fin === 0) {
                            fragmentStartFrameHeader = frame;
                            currentFrameHeader = frame;
                            continue main;
                        }
                        currentFrameHeader = frame;
                        continue main;
                    }
                }
            }
            catch (error) {
                this.onClose(1002, 'DATA');
            }
        };
        const handleClose = (hadError) => {
            if (this.closed)
                return;
            this.onClose(hadError ? 1001 : 1002, 'END');
        };
        socket.on('data', handleData);
        socket.on('close', handleClose);
    }
    close() {
        const code = 1000;
        const reason = 'CLOSE';
        const frame = this.encoder.encodeClose(reason, code);
        this.socket.write(frame);
        this.onClose(code, reason);
    }
    onClose(code, reason) {
        this.closed = true;
        if (this.__writeTimer) {
            clearImmediate(this.__writeTimer);
            this.__writeTimer = null;
        }
        const socket = this.socket;
        socket.removeAllListeners();
        if (!socket.destroyed)
            socket.destroy();
        this.onclose(code, reason);
    }
    upgrade(secWebSocketKey, secWebSocketProtocol, secWebSocketExtensions) {
        const accept = secWebSocketKey + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
        const acceptSha1 = crypto.createHash('sha1').update(accept).digest('base64');
        this.socket.write('HTTP/1.1 101 Switching Protocols\r\n' +
            'Upgrade: websocket\r\n' +
            'Connection: Upgrade\r\n' +
            'Sec-WebSocket-Accept: ' + acceptSha1 + '\r\n' +
            (secWebSocketProtocol ? 'Sec-WebSocket-Protocol: ' + secWebSocketProtocol + '\r\n' : '') +
            '\r\n');
    }
    write(buf) {
        if (this.closed)
            return;
        this.__buffer.push(buf);
        if (this.__writeTimer)
            return;
        this.__writeTimer = setImmediate(() => {
            this.__writeTimer = null;
            const buffer = this.__buffer;
            this.__buffer = [];
            if (!buffer.length)
                return;
            const socket = this.socket;
            if (socket.writableLength > this.maxBackpressure)
                this.onClose(1009, 'BACKPRESSURE');
            socket.cork();
            for (let i = 0, len = buffer.length; i < len; i++)
                socket.write(buffer[i]);
            socket.uncork();
        });
    }
    sendPing(data) {
        const frame = this.encoder.encodePing(data);
        this.write(frame);
    }
    sendPong(data) {
        const frame = this.encoder.encodePong(data);
        this.write(frame);
    }
    sendBinMsg(data) {
        const encoder = this.encoder;
        const header = encoder.encodeDataMsgHdrFast(data.length);
        this.write(header);
        this.write(data);
    }
    sendTxtMsg(txt) {
        const encoder = this.encoder;
        const writer = encoder.writer;
        const size = (0, utf8_1.utf8Size)(txt);
        encoder.writeHdr(1, 1, size, 0);
        writer.ensureCapacity(size);
        writer.utf8(txt);
        const buf = writer.flush();
        this.write(buf);
    }
}
exports.WsServerConnection = WsServerConnection;
