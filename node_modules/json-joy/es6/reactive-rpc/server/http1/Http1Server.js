"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Http1Server = exports.Http1EndpointMatch = void 0;
const tslib_1 = require("tslib");
const http = tslib_1.__importStar(require("http"));
const WsServerConnection_1 = require("../ws/server/WsServerConnection");
const WsFrameEncoder_1 = require("../ws/codec/WsFrameEncoder");
const Writer_1 = require("../../../util/buffers/Writer");
const router_1 = require("../../../util/router");
const printTree_1 = require("../../../util/print/printTree");
const errors_1 = require("./errors");
const util_1 = require("./util");
const context_1 = require("./context");
const RpcCodecs_1 = require("../../common/codec/RpcCodecs");
const Codecs_1 = require("../../../json-pack/codecs/Codecs");
const RpcMessageCodecs_1 = require("../../common/codec/RpcMessageCodecs");
const NullObject_1 = require("../../../util/NullObject");
class Http1EndpointMatch {
    constructor(handler) {
        this.handler = handler;
    }
}
exports.Http1EndpointMatch = Http1EndpointMatch;
class Http1Server {
    static start(opts = {}, port = 8000) {
        const rawServer = http.createServer(opts);
        rawServer.listen(port);
        const server = new Http1Server({ server: rawServer });
        return server;
    }
    constructor(opts) {
        var _a, _b, _c;
        this.opts = opts;
        this.onnotfound = (res) => {
            res.writeHead(404, 'Not Found');
            res.end();
        };
        this.oninternalerror = (error, res) => {
            if (error instanceof errors_1.PayloadTooLarge) {
                res.statusCode = 413;
                res.statusMessage = 'Payload Too Large';
                res.end();
                return;
            }
            res.statusCode = 500;
            res.statusMessage = 'Internal Server Error';
            res.end();
        };
        this.httpRouter = new router_1.Router();
        this.httpMatcher = () => undefined;
        this.onRequest = (req, res) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _d;
            try {
                res.sendDate = false;
                const url = (_d = req.url) !== null && _d !== void 0 ? _d : '';
                const queryStartIndex = url.indexOf('?');
                let path = url;
                let query = '';
                if (queryStartIndex >= 0) {
                    path = url.slice(0, queryStartIndex);
                    query = url.slice(queryStartIndex + 1);
                }
                const route = (req.method || '') + path;
                const match = this.httpMatcher(route);
                if (!match) {
                    this.onnotfound(res, req);
                    return;
                }
                const codecs = this.codecs;
                const ip = this.findIp(req);
                const token = this.findToken(req);
                const ctx = new context_1.Http1ConnectionContext(req, res, path, query, ip, token, match.params, new NullObject_1.NullObject(), codecs.value.json, codecs.value.json, codecs.messages.compact);
                const headers = req.headers;
                const contentType = headers['content-type'];
                if (typeof contentType === 'string')
                    (0, util_1.setCodecs)(ctx, contentType, codecs);
                const handler = match.data.handler;
                yield handler(ctx);
            }
            catch (error) {
                this.oninternalerror(error, res, req);
            }
        });
        this.wsRouter = new router_1.Router();
        this.wsMatcher = () => undefined;
        this.onWsUpgrade = (req, socket) => {
            var _a, _b, _c, _d, _e, _f, _g;
            const url = (_a = req.url) !== null && _a !== void 0 ? _a : '';
            const queryStartIndex = url.indexOf('?');
            let path = url;
            let query = '';
            if (queryStartIndex >= 0) {
                path = url.slice(0, queryStartIndex);
                query = url.slice(queryStartIndex + 1);
            }
            const match = this.wsMatcher(path);
            if (!match) {
                socket.end();
                return;
            }
            const def = match.data;
            const headers = req.headers;
            const connection = new WsServerConnection_1.WsServerConnection(this.wsEncoder, socket);
            connection.maxIncomingMessage = (_b = def.maxIncomingMessage) !== null && _b !== void 0 ? _b : 2 * 1024 * 1024;
            connection.maxBackpressure = (_c = def.maxOutgoingBackpressure) !== null && _c !== void 0 ? _c : 2 * 1024 * 1024;
            if (def.onUpgrade)
                def.onUpgrade(req, connection);
            else {
                const secWebSocketKey = (_d = headers['sec-websocket-key']) !== null && _d !== void 0 ? _d : '';
                const secWebSocketProtocol = (_e = headers['sec-websocket-protocol']) !== null && _e !== void 0 ? _e : '';
                const secWebSocketExtensions = (_f = headers['sec-websocket-extensions']) !== null && _f !== void 0 ? _f : '';
                connection.upgrade(secWebSocketKey, secWebSocketProtocol, secWebSocketExtensions);
            }
            const codecs = this.codecs;
            const ip = this.findIp(req);
            const token = this.findToken(req);
            const ctx = new context_1.WsConnectionContext(connection, path, query, ip, token, match.params, new NullObject_1.NullObject(), codecs.value.json, codecs.value.json, codecs.messages.compact);
            const contentType = headers['content-type'];
            if (typeof contentType === 'string')
                (0, util_1.setCodecs)(ctx, contentType, codecs);
            else {
                const secWebSocketProtocol = (_g = headers['sec-websocket-protocol']) !== null && _g !== void 0 ? _g : '';
                if (typeof secWebSocketProtocol === 'string')
                    (0, util_1.setCodecs)(ctx, secWebSocketProtocol, codecs);
            }
            def.handler(ctx, req);
        };
        this.server = opts.server;
        const writer = (_a = opts.writer) !== null && _a !== void 0 ? _a : new Writer_1.Writer();
        this.codecs = (_b = opts.codecs) !== null && _b !== void 0 ? _b : new RpcCodecs_1.RpcCodecs((_c = opts.codecs) !== null && _c !== void 0 ? _c : new Codecs_1.Codecs(writer), new RpcMessageCodecs_1.RpcMessageCodecs());
        this.wsEncoder = new WsFrameEncoder_1.WsFrameEncoder(writer);
    }
    start() {
        const server = this.server;
        this.httpMatcher = this.httpRouter.compile();
        this.wsMatcher = this.wsRouter.compile();
        server.on('request', this.onRequest);
        server.on('upgrade', this.onWsUpgrade);
        server.on('clientError', (err, socket) => {
            socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
        });
    }
    route(def) {
        let path = def.path;
        if (path[0] !== '/')
            path = '/' + path;
        const method = def.method ? def.method.toUpperCase() : 'GET';
        const route = method + path;
        Number(route);
        const match = new Http1EndpointMatch(def.handler);
        this.httpRouter.add(route, match);
    }
    ws(def) {
        this.wsRouter.add(def.path, def);
    }
    findIp(req) {
        const headers = req.headers;
        const ip = headers['x-forwarded-for'] || headers['x-real-ip'] || req.socket.remoteAddress || '';
        return ip instanceof Array ? ip[0] : ip;
    }
    findToken(req) {
        let token = '';
        const headers = req.headers;
        let header;
        header = headers.authorization;
        if (typeof header === 'string')
            token = (0, util_1.findTokenInText)(header);
        if (token)
            return token;
        const url = req.url;
        if (typeof url === 'string')
            token = (0, util_1.findTokenInText)(url);
        if (token)
            return token;
        header = headers.cookie;
        if (typeof header === 'string')
            token = (0, util_1.findTokenInText)(header);
        if (token)
            return token;
        header = headers['sec-websocket-protocol'];
        if (typeof header === 'string')
            token = (0, util_1.findTokenInText)(header);
        return token;
    }
    enableHttpPing(path = '/ping') {
        this.route({
            path,
            handler: (ctx) => {
                ctx.res.end('"pong"');
            },
        });
    }
    toString(tab = '') {
        return (`${this.constructor.name}` +
            (0, printTree_1.printTree)(tab, [
                (tab) => `HTTP ${this.httpRouter.toString(tab)}`,
                (tab) => `WebSocket ${this.wsRouter.toString(tab)}`,
            ]));
    }
}
exports.Http1Server = Http1Server;
