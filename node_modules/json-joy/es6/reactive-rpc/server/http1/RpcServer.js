"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcServer = void 0;
const tslib_1 = require("tslib");
const http = tslib_1.__importStar(require("http"));
const printTree_1 = require("../../../util/print/printTree");
const Http1Server_1 = require("./Http1Server");
const caller_1 = require("../../common/rpc/caller");
const common_1 = require("../../common");
const DEFAULT_MAX_PAYLOAD = 4 * 1024 * 1024;
class RpcServer {
    constructor(opts) {
        this.opts = opts;
        const http1 = (this.http1 = opts.http1);
        const onInternalError = http1.oninternalerror;
        http1.oninternalerror = (error, res, req) => {
            if (error instanceof caller_1.RpcError) {
                res.statusCode = 400;
                const data = JSON.stringify(error.toJson());
                res.end(data);
                return;
            }
            onInternalError(error, res, req);
        };
        this.batchProcessor = new common_1.RpcMessageBatchProcessor({ caller: opts.caller });
    }
    enableHttpPing() {
        this.http1.enableHttpPing();
    }
    enableCors() {
        this.http1.route({
            method: 'OPTIONS',
            path: '/{::\n}',
            handler: (ctx) => {
                const res = ctx.res;
                res.writeHead(200, 'OK', {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Credentials': 'true',
                });
                res.end();
            },
        });
    }
    enableHttpRpc(path = '/rpc') {
        var _a;
        const batchProcessor = this.batchProcessor;
        const logger = (_a = this.opts.logger) !== null && _a !== void 0 ? _a : console;
        this.http1.route({
            method: 'POST',
            path,
            handler: (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const res = ctx.res;
                const body = yield ctx.body(DEFAULT_MAX_PAYLOAD);
                if (!res.socket)
                    return;
                try {
                    const messageCodec = ctx.msgCodec;
                    const incomingMessages = messageCodec.decodeBatch(ctx.reqCodec, body);
                    try {
                        const outgoingMessages = yield batchProcessor.onBatch(incomingMessages, ctx);
                        if (!res.socket)
                            return;
                        const resCodec = ctx.resCodec;
                        messageCodec.encodeBatch(resCodec, outgoingMessages);
                        const buf = resCodec.encoder.writer.flush();
                        if (!res.socket)
                            return;
                        res.end(buf);
                    }
                    catch (error) {
                        logger.error('HTTP_RPC_PROCESSING', error, { messages: incomingMessages });
                        throw caller_1.RpcError.from(error);
                    }
                }
                catch (error) {
                    if (typeof error === 'object' && error)
                        if (error.message === 'Invalid JSON')
                            throw caller_1.RpcError.badRequest();
                    throw caller_1.RpcError.from(error);
                }
            }),
        });
    }
    enableWsRpc(path = '/rpc') {
        var _a;
        const opts = this.opts;
        const logger = (_a = opts.logger) !== null && _a !== void 0 ? _a : console;
        const caller = opts.caller;
        this.http1.ws({
            path,
            maxIncomingMessage: 2 * 1024 * 1024,
            maxOutgoingBackpressure: 2 * 1024 * 1024,
            handler: (ctx, req) => {
                const connection = ctx.connection;
                const reqCodec = ctx.reqCodec;
                const resCodec = ctx.resCodec;
                const msgCodec = ctx.msgCodec;
                const encoder = resCodec.encoder;
                const rpc = new common_1.RpcMessageStreamProcessor({
                    caller,
                    send: (messages) => {
                        try {
                            const writer = encoder.writer;
                            writer.reset();
                            msgCodec.encodeBatch(resCodec, messages);
                            const encoded = writer.flush();
                            connection.sendBinMsg(encoded);
                        }
                        catch (error) {
                            logger.error('WS_SEND', error, { messages });
                            connection.close();
                        }
                    },
                    bufferSize: 1,
                    bufferTime: 0,
                });
                connection.onmessage = (uint8, isUtf8) => {
                    let messages;
                    try {
                        messages = msgCodec.decodeBatch(reqCodec, uint8);
                    }
                    catch (error) {
                        logger.error('RX_RPC_DECODING', error, { codec: reqCodec.id, buf: Buffer.from(uint8).toString('base64') });
                        connection.close();
                        return;
                    }
                    try {
                        rpc.onMessages(messages, ctx);
                    }
                    catch (error) {
                        logger.error('RX_RPC_PROCESSING', error, messages);
                        connection.close();
                        return;
                    }
                };
                connection.onclose = (code, reason) => {
                    rpc.stop();
                };
            },
        });
    }
    enableDefaults() {
        this.enableCors();
        this.enableHttpPing();
        this.enableHttpRpc();
        this.enableWsRpc();
    }
    toString(tab = '') {
        return `${this.constructor.name}` + (0, printTree_1.printTree)(tab, [(tab) => this.http1.toString(tab)]);
    }
}
exports.RpcServer = RpcServer;
RpcServer.create = (opts) => {
    const server = new RpcServer(opts);
    opts.http1.enableHttpPing();
    return server;
};
RpcServer.startWithDefaults = (opts) => {
    var _a, _b;
    const port = (_a = opts.port) !== null && _a !== void 0 ? _a : 8080;
    const logger = (_b = opts.logger) !== null && _b !== void 0 ? _b : console;
    const server = http.createServer();
    const http1Server = new Http1Server_1.Http1Server({
        server,
    });
    const rpcServer = new RpcServer({
        caller: opts.caller,
        http1: http1Server,
        logger,
    });
    rpcServer.enableDefaults();
    http1Server.start();
    server.listen(port, () => {
        let host = server.address() || 'localhost';
        if (typeof host === 'object')
            host = host.address;
        logger.log({ msg: 'SERVER_STARTED', host, port });
    });
    return rpcServer;
};
