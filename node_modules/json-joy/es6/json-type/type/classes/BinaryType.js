"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryType = void 0;
const tslib_1 = require("tslib");
const schema = tslib_1.__importStar(require("../../schema"));
const json_random_1 = require("../../../json-random");
const json_binary_1 = require("../../../json-binary");
const printTree_1 = require("../../../util/print/printTree");
const validate_1 = require("../../schema/validate");
const constants_1 = require("../../constants");
const AbstractType_1 = require("./AbstractType");
class BinaryType extends AbstractType_1.AbstractType {
    constructor(type, options) {
        super();
        this.type = type;
        this.schema = schema.s.Binary(schema.s.any, options);
    }
    getSchema() {
        return Object.assign(Object.assign({}, this.schema), { type: this.type.getSchema() });
    }
    toJsonSchema(ctx) {
        return Object.assign({ type: 'binary' }, super.toJsonSchema(ctx));
    }
    getOptions() {
        const _a = this.schema, { __t, type } = _a, options = tslib_1.__rest(_a, ["__t", "type"]);
        return options;
    }
    validateSchema() {
        (0, validate_1.validateTType)(this.getSchema(), 'bin');
        this.type.validateSchema();
    }
    codegenValidator(ctx, path, r) {
        const hasBuffer = typeof Buffer === 'function';
        const err = ctx.err(constants_1.ValidationError.BIN, path);
        ctx.js(`if(!(${r} instanceof Uint8Array)${hasBuffer ? ` && !Buffer.isBuffer(${r})` : ''}) return ${err};`);
        ctx.emitCustomValidators(this, path, r);
    }
    codegenJsonTextEncoder(ctx, value) {
        ctx.linkBase64();
        ctx.writeText('"data:application/octet-stream;base64,');
        ctx.js(`s += toBase64(${value.use()});`);
        ctx.writeText('"');
    }
    codegenBinaryEncoder(ctx, value) {
        ctx.js(`encoder.writeBin(${value.use()});`);
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        ctx.inc(41);
        ctx.codegen.js(`size += ${2} * ${value.use()}.length;`);
    }
    random() {
        const octets = json_random_1.RandomJson.genString()
            .split('')
            .map((c) => c.charCodeAt(0));
        return new Uint8Array(octets);
    }
    toTypeScriptAst() {
        return {
            node: 'GenericTypeAnnotation',
            id: {
                node: 'Identifier',
                name: 'Uint8Array',
            },
        };
    }
    toJson(value, system = this.system) {
        return ('"' + (0, json_binary_1.stringifyBinary)(value) + '"');
    }
    toString(tab = '') {
        return super.toString(tab) + (0, printTree_1.printTree)(tab, [(tab) => this.type.toString(tab)]);
    }
}
exports.BinaryType = BinaryType;
