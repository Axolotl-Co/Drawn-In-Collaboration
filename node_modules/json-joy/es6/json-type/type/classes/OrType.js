"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrType = void 0;
const tslib_1 = require("tslib");
const schema = tslib_1.__importStar(require("../../schema"));
const printTree_1 = require("../../../util/print/printTree");
const validate_1 = require("../../schema/validate");
const constants_1 = require("../../constants");
const CborEncoderCodegenContext_1 = require("../../codegen/binary/CborEncoderCodegenContext");
const JsonEncoderCodegenContext_1 = require("../../codegen/binary/JsonEncoderCodegenContext");
const MessagePackEncoderCodegenContext_1 = require("../../codegen/binary/MessagePackEncoderCodegenContext");
const json_expression_1 = require("../../../json-expression");
const operators_1 = require("../../../json-expression/operators");
const Vars_1 = require("../../../json-expression/Vars");
const discriminator_1 = require("../discriminator");
const AbstractType_1 = require("./AbstractType");
class OrType extends AbstractType_1.AbstractType {
    constructor(types, options) {
        var _a;
        super();
        this.types = types;
        this.__discriminator = undefined;
        this.schema = Object.assign(Object.assign(Object.assign({}, schema.s.Or()), options), { discriminator: (_a = options === null || options === void 0 ? void 0 : options.discriminator) !== null && _a !== void 0 ? _a : discriminator_1.Discriminator.createExpression(types) });
    }
    getSchema() {
        return Object.assign(Object.assign({}, this.schema), { types: this.types.map((type) => type.getSchema()) });
    }
    toJsonSchema(ctx) {
        return {
            anyOf: this.types.map((type) => type.toJsonSchema(ctx)),
        };
    }
    getOptions() {
        const _a = this.schema, { __t, types } = _a, options = tslib_1.__rest(_a, ["__t", "types"]);
        return options;
    }
    options(options) {
        Object.assign(this.schema, options);
        return this;
    }
    discriminator() {
        if (this.__discriminator)
            return this.__discriminator;
        const expr = this.schema.discriminator;
        if (!expr || (expr[0] === 'num' && expr[1] === 0))
            throw new Error('NO_DISCRIMINATOR');
        const codegen = new json_expression_1.JsonExpressionCodegen({
            expression: expr,
            operators: operators_1.operatorsMap,
        });
        const fn = codegen.run().compile();
        return (this.__discriminator = (data) => +fn({ vars: new Vars_1.Vars(data) }));
    }
    validateSchema() {
        const schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'or');
        const { types, discriminator } = schema;
        if (!discriminator || (discriminator[0] === 'num' && discriminator[1] === -1))
            throw new Error('DISCRIMINATOR');
        if (!Array.isArray(types))
            throw new Error('TYPES_TYPE');
        if (!types.length)
            throw new Error('TYPES_LENGTH');
        for (const type of this.types)
            type.validateSchema();
    }
    codegenValidator(ctx, path, r) {
        const types = this.types;
        const codegen = ctx.codegen;
        const length = types.length;
        if (length === 1) {
            types[0].codegenValidator(ctx, path, r);
            return;
        }
        const discriminator = this.discriminator();
        const d = codegen.linkDependency(discriminator);
        codegen.switch(`${d}(${r})`, types.map((type, index) => [
            index,
            () => {
                type.codegenValidator(ctx, path, r);
            },
        ]), () => {
            const err = ctx.err(constants_1.ValidationError.OR, path);
            ctx.js(`return ${err}`);
        });
    }
    codegenJsonTextEncoder(ctx, value) {
        ctx.js(`s += stringify(${value.use()});`);
    }
    codegenBinaryEncoder(ctx, value) {
        const codegen = ctx.codegen;
        const discriminator = this.discriminator();
        const d = codegen.linkDependency(discriminator);
        const types = this.types;
        codegen.switch(`${d}(${value.use()})`, types.map((type, index) => [
            index,
            () => {
                if (ctx instanceof CborEncoderCodegenContext_1.CborEncoderCodegenContext)
                    type.codegenCborEncoder(ctx, value);
                else if (ctx instanceof MessagePackEncoderCodegenContext_1.MessagePackEncoderCodegenContext)
                    type.codegenMessagePackEncoder(ctx, value);
                else if (ctx instanceof JsonEncoderCodegenContext_1.JsonEncoderCodegenContext)
                    type.codegenJsonEncoder(ctx, value);
            },
        ]));
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        const codegen = ctx.codegen;
        const discriminator = this.discriminator();
        const d = codegen.linkDependency(discriminator);
        const types = this.types;
        codegen.switch(`${d}(${value.use()})`, types.map((type, index) => [
            index,
            () => {
                type.codegenCapacityEstimator(ctx, value);
            },
        ]));
    }
    random() {
        const types = this.types;
        const index = Math.floor(Math.random() * types.length);
        return types[index].random();
    }
    toTypeScriptAst() {
        const node = {
            node: 'UnionType',
            types: this.types.map((t) => t.toTypeScriptAst()),
        };
        return node;
    }
    toJson(value, system = this.system) {
        return JSON.stringify(value);
    }
    toString(tab = '') {
        return super.toString(tab) + (0, printTree_1.printTree)(tab, [...this.types.map((type) => (tab) => type.toString(tab))]);
    }
}
exports.OrType = OrType;
