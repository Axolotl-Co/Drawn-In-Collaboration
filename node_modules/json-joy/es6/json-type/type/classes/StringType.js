"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringType = void 0;
const json_random_1 = require("../../../json-random");
const asString_1 = require("../../../util/strings/asString");
const validate_1 = require("../../schema/validate");
const constants_1 = require("../../constants");
const AbstractType_1 = require("./AbstractType");
class StringType extends AbstractType_1.AbstractType {
    constructor(schema) {
        super();
        this.schema = schema;
    }
    toJsonSchema(ctx) {
        const schema = this.getSchema();
        const jsonSchema = Object.assign({ type: 'string' }, super.toJsonSchema(ctx));
        if (schema.min !== undefined)
            jsonSchema.minLength = schema.min;
        if (schema.max !== undefined)
            jsonSchema.maxLength = schema.max;
        return jsonSchema;
    }
    validateSchema() {
        const schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'str');
        (0, validate_1.validateWithValidator)(schema);
        const { min, max, ascii, noJsonEscape } = schema;
        (0, validate_1.validateMinMax)(min, max);
        if (ascii !== undefined) {
            if (typeof ascii !== 'boolean')
                throw new Error('ASCII');
        }
        if (noJsonEscape !== undefined) {
            if (typeof noJsonEscape !== 'boolean')
                throw new Error('NO_JSON_ESCAPE_TYPE');
        }
    }
    codegenValidator(ctx, path, r) {
        const error = ctx.err(constants_1.ValidationError.STR, path);
        ctx.js(`if(typeof ${r} !== "string") return ${error};`);
        const { min, max } = this.schema;
        if (typeof min === 'number' && min === max) {
            const err = ctx.err(constants_1.ValidationError.STR_LEN, path);
            ctx.js(`if(${r}.length !== ${min}) return ${err};`);
        }
        else {
            if (typeof min === 'number') {
                const err = ctx.err(constants_1.ValidationError.STR_LEN, path);
                ctx.js(`if(${r}.length < ${min}) return ${err};`);
            }
            if (typeof max === 'number') {
                const err = ctx.err(constants_1.ValidationError.STR_LEN, path);
                ctx.js(`if(${r}.length > ${max}) return ${err};`);
            }
        }
        ctx.emitCustomValidators(this, path, r);
    }
    codegenJsonTextEncoder(ctx, value) {
        if (this.schema.noJsonEscape) {
            ctx.writeText('"');
            ctx.js(`s += ${value.use()};`);
            ctx.writeText('"');
        }
        else
            ctx.js(`s += asString(${value.use()});`);
    }
    codegenBinaryEncoder(ctx, value) {
        const ascii = this.schema.ascii;
        const v = value.use();
        if (ascii)
            ctx.js(`encoder.writeAsciiStr(${v});`);
        else
            ctx.js(`encoder.writeStr(${v});`);
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        ctx.inc(5);
        ctx.codegen.js(`size += ${5} * ${value.use()}.length;`);
    }
    random() {
        let length = Math.round(Math.random() * 10);
        const { min, max } = this.schema;
        if (min !== undefined && length < min)
            length = min + length;
        if (max !== undefined && length > max)
            length = max;
        return json_random_1.RandomJson.genString(length);
    }
    toTypeScriptAst() {
        return { node: 'StringKeyword' };
    }
    toJson(value, system = this.system) {
        return (this.schema.noJsonEscape ? '"' + value + '"' : (0, asString_1.asString)(value));
    }
    toJtdForm() {
        return { type: 'string' };
    }
}
exports.StringType = StringType;
