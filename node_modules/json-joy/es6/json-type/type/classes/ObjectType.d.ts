import * as schema from '../../schema';
import { ValidatorCodegenContext } from '../../codegen/validator/ValidatorCodegenContext';
import { ValidationPath } from '../../codegen/validator/types';
import { JsonTextEncoderCodegenContext } from '../../codegen/json/JsonTextEncoderCodegenContext';
import { CborEncoderCodegenContext } from '../../codegen/binary/CborEncoderCodegenContext';
import { JsonEncoderCodegenContext } from '../../codegen/binary/JsonEncoderCodegenContext';
import { JsExpression } from '../../../util/codegen/util/JsExpression';
import { MessagePackEncoderCodegenContext } from '../../codegen/binary/MessagePackEncoderCodegenContext';
import { CapacityEstimatorCodegenContext } from '../../codegen/capacity/CapacityEstimatorCodegenContext';
import { AbstractType } from './AbstractType';
import type * as jsonSchema from '../../../json-schema';
import type { SchemaOf, SchemaOfObjectFields, Type } from '../types';
import type { TypeSystem } from '../../system/TypeSystem';
import type { json_string } from '../../../json-brand';
import type * as ts from '../../typescript/types';
import type { TypeExportContext } from '../../system/TypeExportContext';
export declare class ObjectFieldType<K extends string, V extends Type> extends AbstractType<schema.ObjectFieldSchema<K, SchemaOf<V>>> {
    readonly key: K;
    readonly value: V;
    protected schema: schema.ObjectFieldSchema<K, any>;
    constructor(key: K, value: V);
    getSchema(): schema.ObjectFieldSchema<K, SchemaOf<V>>;
    getOptions(): schema.Optional<schema.ObjectFieldSchema<K, SchemaOf<V>>>;
    validateSchema(): void;
    protected toStringTitle(): string;
    toString(tab?: string): string;
}
export declare class ObjectOptionalFieldType<K extends string, V extends Type> extends ObjectFieldType<K, V> {
    readonly key: K;
    readonly value: V;
    optional: boolean;
    constructor(key: K, value: V);
    protected toStringTitle(): string;
}
export declare class ObjectType<F extends ObjectFieldType<any, any>[] = ObjectFieldType<any, any>[]> extends AbstractType<schema.ObjectSchema<SchemaOfObjectFields<F>>> {
    readonly fields: F;
    protected schema: schema.ObjectSchema<any>;
    constructor(fields: F);
    getSchema(): schema.ObjectSchema<SchemaOfObjectFields<F>>;
    toJsonSchema(ctx?: TypeExportContext): jsonSchema.JsonSchemaObject;
    getOptions(): schema.Optional<schema.ObjectSchema<SchemaOfObjectFields<F>>>;
    getField(key: string): ObjectFieldType<string, Type> | undefined;
    validateSchema(): void;
    codegenValidator(ctx: ValidatorCodegenContext, path: ValidationPath, r: string): void;
    codegenJsonTextEncoder(ctx: JsonTextEncoderCodegenContext, value: JsExpression): void;
    codegenCborEncoder(ctx: CborEncoderCodegenContext, value: JsExpression): void;
    codegenMessagePackEncoder(ctx: MessagePackEncoderCodegenContext, value: JsExpression): void;
    codegenJsonEncoder(ctx: JsonEncoderCodegenContext, value: JsExpression): void;
    codegenCapacityEstimator(ctx: CapacityEstimatorCodegenContext, value: JsExpression): void;
    random(): Record<string, unknown>;
    toTypeScriptAst(): ts.TsTypeLiteral;
    toJson(value: unknown, system?: TypeSystem | undefined): json_string<unknown>;
    toString(tab?: string): string;
}
