"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnNewFanOut = exports.MapFanOut = exports.MicrotaskBufferFanOut = exports.MergeFanOut = void 0;
const fanout_1 = require("thingies/es2020/fanout");
class MergeFanOut extends fanout_1.FanOut {
    constructor(fanouts) {
        super();
        this.fanouts = fanouts;
        this.unsubs = [];
    }
    listen(listener) {
        if (!this.listeners.size)
            this.unsubs = this.fanouts.map((fanout) => fanout.listen((data) => this.emit(data)));
        const unsub = super.listen(listener);
        return () => {
            unsub();
            if (!this.listeners.size) {
                this.unsubs.forEach((unsub) => unsub());
                this.unsubs = [];
            }
        };
    }
}
exports.MergeFanOut = MergeFanOut;
class MicrotaskBufferFanOut extends fanout_1.FanOut {
    constructor(source) {
        super();
        this.source = source;
        this.buffer = [];
        this.unsub = undefined;
    }
    listen(listener) {
        if (!this.unsub) {
            this.unsub = this.source.listen((data) => {
                const buffer = this.buffer;
                if (!buffer.length) {
                    queueMicrotask(() => {
                        this.emit(buffer);
                        this.buffer = [];
                    });
                }
                buffer.push(data);
            });
        }
        const unsub = super.listen(listener);
        return () => {
            unsub();
            if (!this.listeners.size)
                this.clear();
        };
    }
    clear() {
        var _a;
        this.listeners.clear();
        this.buffer = [];
        (_a = this.unsub) === null || _a === void 0 ? void 0 : _a.call(this);
        this.unsub = undefined;
    }
}
exports.MicrotaskBufferFanOut = MicrotaskBufferFanOut;
class MapFanOut extends fanout_1.FanOut {
    constructor(source, mapper) {
        super();
        this.source = source;
        this.mapper = mapper;
        this.unsub = undefined;
    }
    listen(listener) {
        if (!this.unsub)
            this.unsub = this.source.listen((data) => this.emit(this.mapper(data)));
        const unsub = super.listen(listener);
        return () => {
            unsub();
            if (!this.listeners.size)
                this.clear();
        };
    }
    clear() {
        var _a;
        this.listeners.clear();
        (_a = this.unsub) === null || _a === void 0 ? void 0 : _a.call(this);
        this.unsub = undefined;
    }
}
exports.MapFanOut = MapFanOut;
class OnNewFanOut extends fanout_1.FanOut {
    constructor(source) {
        super();
        this.source = source;
        this.last = undefined;
        this.unsub = undefined;
    }
    listen(listener) {
        if (!this.unsub) {
            this.unsub = this.source.listen((data) => {
                if (this.last !== data)
                    this.emit((this.last = data));
            });
        }
        const unsub = super.listen(listener);
        return () => {
            unsub();
            if (!this.listeners.size)
                this.clear();
        };
    }
    clear() {
        var _a;
        this.listeners.clear();
        this.last = undefined;
        (_a = this.unsub) === null || _a === void 0 ? void 0 : _a.call(this);
        this.unsub = undefined;
    }
}
exports.OnNewFanOut = OnNewFanOut;
