import { MemoryStore } from './MemoryStore';
import { RpcError, RpcErrorCodes } from '../../../reactive-rpc/common/rpc/caller';
const BLOCK_TTL = 1000 * 60 * 60;
const validatePatches = (patches) => {
    for (const patch of patches) {
        if (patch.blob.length > 2000)
            throw RpcError.validation('patch blob too large');
        if (patch.seq > 500_000)
            throw RpcError.validation('patch seq too large');
    }
};
export class BlocksServices {
    services;
    store = new MemoryStore();
    constructor(services) {
        this.services = services;
    }
    async create(id, patches) {
        this.maybeGc();
        const { store } = this;
        validatePatches(patches);
        const { block } = await store.create(id, patches);
        const data = {
            block,
            patches,
        };
        this.services.pubsub.publish(`__block:${id}`, data).catch((error) => {
            console.error('Error publishing block patches', error);
        });
        return { block };
    }
    async get(id) {
        const { store } = this;
        const result = await store.get(id);
        if (!result)
            throw RpcError.fromCode(RpcErrorCodes.NOT_FOUND);
        const patches = await store.history(id, 0, result.block.seq);
        const { block } = result;
        return { block, patches };
    }
    async remove(id) {
        await this.store.remove(id);
        this.services.pubsub.publish(`__block:${id}`, { deleted: true }).catch((error) => {
            console.error('Error publishing block deletion', error);
        });
    }
    async history(id, min, max) {
        const { store } = this;
        const patches = await store.history(id, min, max);
        return { patches };
    }
    async edit(id, patches) {
        this.maybeGc();
        if (!Array.isArray(patches))
            throw RpcError.validation('patches must be an array');
        if (!patches.length)
            throw RpcError.validation('patches must not be empty');
        const seq = patches[0].seq;
        const { store } = this;
        validatePatches(patches);
        const { block } = await store.edit(id, patches);
        this.services.pubsub.publish(`__block:${id}`, { patches }).catch((error) => {
            console.error('Error publishing block patches', error);
        });
        const expectedBlockSeq = seq + patches.length - 1;
        const hadConcurrentEdits = block.seq !== expectedBlockSeq;
        let patchesBack = [];
        if (hadConcurrentEdits) {
            patchesBack = await store.history(id, seq, block.seq);
        }
        return {
            block,
            patches: patchesBack,
        };
    }
    stats() {
        return this.store.stats();
    }
    maybeGc() {
        if (Math.random() < 0.05)
            this.gc().catch((error) => {
                console.error('Error running gc', error);
            });
    }
    async gc() {
        const ts = Date.now() - BLOCK_TTL;
        const { store } = this;
        await store.removeOlderThan(ts);
    }
}
