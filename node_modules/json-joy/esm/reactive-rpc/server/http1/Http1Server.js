import * as http from 'http';
import { WsServerConnection } from '../ws/server/WsServerConnection';
import { WsFrameEncoder } from '../ws/codec/WsFrameEncoder';
import { Writer } from '../../../util/buffers/Writer';
import { Router } from '../../../util/router';
import { printTree } from '../../../util/print/printTree';
import { PayloadTooLarge } from './errors';
import { findTokenInText, setCodecs } from './util';
import { Http1ConnectionContext, WsConnectionContext } from './context';
import { RpcCodecs } from '../../common/codec/RpcCodecs';
import { Codecs } from '../../../json-pack/codecs/Codecs';
import { RpcMessageCodecs } from '../../common/codec/RpcMessageCodecs';
import { NullObject } from '../../../util/NullObject';
export class Http1EndpointMatch {
    handler;
    constructor(handler) {
        this.handler = handler;
    }
}
export class Http1Server {
    opts;
    static start(opts = {}, port = 8000) {
        const rawServer = http.createServer(opts);
        rawServer.listen(port);
        const server = new Http1Server({ server: rawServer });
        return server;
    }
    codecs;
    server;
    constructor(opts) {
        this.opts = opts;
        this.server = opts.server;
        const writer = opts.writer ?? new Writer();
        this.codecs = opts.codecs ?? new RpcCodecs(opts.codecs ?? new Codecs(writer), new RpcMessageCodecs());
        this.wsEncoder = new WsFrameEncoder(writer);
    }
    start() {
        const server = this.server;
        this.httpMatcher = this.httpRouter.compile();
        this.wsMatcher = this.wsRouter.compile();
        server.on('request', this.onRequest);
        server.on('upgrade', this.onWsUpgrade);
        server.on('clientError', (err, socket) => {
            socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
        });
    }
    onnotfound = (res) => {
        res.writeHead(404, 'Not Found');
        res.end();
    };
    oninternalerror = (error, res) => {
        if (error instanceof PayloadTooLarge) {
            res.statusCode = 413;
            res.statusMessage = 'Payload Too Large';
            res.end();
            return;
        }
        res.statusCode = 500;
        res.statusMessage = 'Internal Server Error';
        res.end();
    };
    httpRouter = new Router();
    httpMatcher = () => undefined;
    route(def) {
        let path = def.path;
        if (path[0] !== '/')
            path = '/' + path;
        const method = def.method ? def.method.toUpperCase() : 'GET';
        const route = method + path;
        Number(route);
        const match = new Http1EndpointMatch(def.handler);
        this.httpRouter.add(route, match);
    }
    onRequest = async (req, res) => {
        try {
            res.sendDate = false;
            const url = req.url ?? '';
            const queryStartIndex = url.indexOf('?');
            let path = url;
            let query = '';
            if (queryStartIndex >= 0) {
                path = url.slice(0, queryStartIndex);
                query = url.slice(queryStartIndex + 1);
            }
            const route = (req.method || '') + path;
            const match = this.httpMatcher(route);
            if (!match) {
                this.onnotfound(res, req);
                return;
            }
            const codecs = this.codecs;
            const ip = this.findIp(req);
            const token = this.findToken(req);
            const ctx = new Http1ConnectionContext(req, res, path, query, ip, token, match.params, new NullObject(), codecs.value.json, codecs.value.json, codecs.messages.compact);
            const headers = req.headers;
            const contentType = headers['content-type'];
            if (typeof contentType === 'string')
                setCodecs(ctx, contentType, codecs);
            const handler = match.data.handler;
            await handler(ctx);
        }
        catch (error) {
            this.oninternalerror(error, res, req);
        }
    };
    wsEncoder;
    wsRouter = new Router();
    wsMatcher = () => undefined;
    onWsUpgrade = (req, socket) => {
        const url = req.url ?? '';
        const queryStartIndex = url.indexOf('?');
        let path = url;
        let query = '';
        if (queryStartIndex >= 0) {
            path = url.slice(0, queryStartIndex);
            query = url.slice(queryStartIndex + 1);
        }
        const match = this.wsMatcher(path);
        if (!match) {
            socket.end();
            return;
        }
        const def = match.data;
        const headers = req.headers;
        const connection = new WsServerConnection(this.wsEncoder, socket);
        connection.maxIncomingMessage = def.maxIncomingMessage ?? 2 * 1024 * 1024;
        connection.maxBackpressure = def.maxOutgoingBackpressure ?? 2 * 1024 * 1024;
        if (def.onUpgrade)
            def.onUpgrade(req, connection);
        else {
            const secWebSocketKey = headers['sec-websocket-key'] ?? '';
            const secWebSocketProtocol = headers['sec-websocket-protocol'] ?? '';
            const secWebSocketExtensions = headers['sec-websocket-extensions'] ?? '';
            connection.upgrade(secWebSocketKey, secWebSocketProtocol, secWebSocketExtensions);
        }
        const codecs = this.codecs;
        const ip = this.findIp(req);
        const token = this.findToken(req);
        const ctx = new WsConnectionContext(connection, path, query, ip, token, match.params, new NullObject(), codecs.value.json, codecs.value.json, codecs.messages.compact);
        const contentType = headers['content-type'];
        if (typeof contentType === 'string')
            setCodecs(ctx, contentType, codecs);
        else {
            const secWebSocketProtocol = headers['sec-websocket-protocol'] ?? '';
            if (typeof secWebSocketProtocol === 'string')
                setCodecs(ctx, secWebSocketProtocol, codecs);
        }
        def.handler(ctx, req);
    };
    ws(def) {
        this.wsRouter.add(def.path, def);
    }
    findIp(req) {
        const headers = req.headers;
        const ip = headers['x-forwarded-for'] || headers['x-real-ip'] || req.socket.remoteAddress || '';
        return ip instanceof Array ? ip[0] : ip;
    }
    findToken(req) {
        let token = '';
        const headers = req.headers;
        let header;
        header = headers.authorization;
        if (typeof header === 'string')
            token = findTokenInText(header);
        if (token)
            return token;
        const url = req.url;
        if (typeof url === 'string')
            token = findTokenInText(url);
        if (token)
            return token;
        header = headers.cookie;
        if (typeof header === 'string')
            token = findTokenInText(header);
        if (token)
            return token;
        header = headers['sec-websocket-protocol'];
        if (typeof header === 'string')
            token = findTokenInText(header);
        return token;
    }
    enableHttpPing(path = '/ping') {
        this.route({
            path,
            handler: (ctx) => {
                ctx.res.end('"pong"');
            },
        });
    }
    toString(tab = '') {
        return (`${this.constructor.name}` +
            printTree(tab, [
                (tab) => `HTTP ${this.httpRouter.toString(tab)}`,
                (tab) => `WebSocket ${this.wsRouter.toString(tab)}`,
            ]));
    }
}
