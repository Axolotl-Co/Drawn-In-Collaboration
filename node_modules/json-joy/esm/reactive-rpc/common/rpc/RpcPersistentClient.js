import { firstValueFrom, ReplaySubject, timer } from 'rxjs';
import { filter, first, share, switchMap, takeUntil } from 'rxjs/operators';
import { StreamingRpcClient } from './client/StreamingRpcClient';
import { PersistentChannel } from '../channel';
export class RpcPersistentClient {
    channel;
    rpc;
    rpc$ = new ReplaySubject(1);
    constructor(params) {
        const ping = params.ping ?? 15000;
        const codec = params.codec;
        const textEncoder = new TextEncoder();
        this.channel = new PersistentChannel(params.channel);
        this.channel.open$.pipe(filter((open) => open)).subscribe(() => {
            const close$ = this.channel.open$.pipe(filter((open) => !open));
            const client = new StreamingRpcClient({
                ...(params.client || {}),
                send: (messages) => {
                    const encoded = codec.encode(messages, codec.req);
                    this.channel.send$(encoded).subscribe();
                },
            });
            this.channel.message$.pipe(takeUntil(close$)).subscribe((data) => {
                const encoded = typeof data === 'string' ? textEncoder.encode(data) : new Uint8Array(data);
                const messages = codec.decode(encoded, codec.res);
                client.onMessages((messages instanceof Array ? messages : [messages]));
            });
            if (ping) {
                timer(ping, ping)
                    .pipe(takeUntil(close$))
                    .subscribe(() => {
                    client.notify(params.pingMethod || '.ping', undefined);
                });
            }
            if (this.rpc)
                this.rpc.disconnect();
            this.rpc = client;
            this.rpc$.next(client);
        });
    }
    call$(method, data) {
        return this.rpc$.pipe(first(), switchMap((rpc) => rpc.call$(method, data)), share());
    }
    call(method, data) {
        return firstValueFrom(this.call$(method, data));
    }
    notify(method, data) {
        this.rpc$.subscribe((rpc) => rpc.notify(method, data));
    }
    start() {
        this.channel.start();
    }
    stop() {
        this.channel.stop();
        if (this.rpc)
            this.rpc.stop();
    }
}
