import * as operations from '../../operations';
import { CrdtWriter } from '../../util/binary/CrdtWriter';
import { Timestamp } from '../../clock';
import { CborEncoder } from '../../../json-pack/cbor/CborEncoder';
export class Encoder extends CborEncoder {
    writer;
    patchSid = 0;
    constructor(writer = new CrdtWriter()) {
        super(writer);
        this.writer = writer;
    }
    encode(patch) {
        this.writer.reset();
        const id = patch.getId();
        const sid = (this.patchSid = id.sid);
        const writer = this.writer;
        writer.vu57(sid);
        writer.vu57(id.time);
        const meta = patch.meta;
        if (meta === undefined)
            this.writeUndef();
        else
            this.writeArr([meta]);
        this.encodeOperations(patch);
        return writer.flush();
    }
    encodeOperations(patch) {
        const ops = patch.ops;
        const length = ops.length;
        this.writer.vu57(length);
        for (let i = 0; i < length; i++)
            this.encodeOperation(ops[i]);
    }
    encodeId(id) {
        const sessionId = id.sid;
        const time = id.time;
        const writer = this.writer;
        if (sessionId === this.patchSid) {
            writer.b1vu56(0, time);
        }
        else {
            writer.b1vu56(1, time);
            writer.vu57(sessionId);
        }
    }
    encodeTss(span) {
        this.encodeId(span);
        this.writer.vu57(span.span);
    }
    writeInsStr(length, obj, ref, str) {
        const writer = this.writer;
        if (length <= 0b111) {
            writer.u8(96 + length);
        }
        else {
            writer.u8(96);
            writer.vu57(length);
        }
        this.encodeId(obj);
        this.encodeId(ref);
        return writer.utf8(str);
    }
    encodeOperation(op) {
        const writer = this.writer;
        const constructor = op.constructor;
        switch (constructor) {
            case operations.NewConOp: {
                const operation = op;
                const val = operation.val;
                if (val instanceof Timestamp) {
                    writer.u8(0 + 1);
                    this.encodeId(val);
                }
                else {
                    writer.u8(0);
                    this.writeAny(val);
                }
                break;
            }
            case operations.NewValOp: {
                writer.u8(8);
                break;
            }
            case operations.NewObjOp: {
                writer.u8(16);
                break;
            }
            case operations.NewVecOp: {
                writer.u8(24);
                break;
            }
            case operations.NewStrOp: {
                writer.u8(32);
                break;
            }
            case operations.NewBinOp: {
                writer.u8(40);
                break;
            }
            case operations.NewArrOp: {
                writer.u8(48);
                break;
            }
            case operations.InsValOp: {
                const operation = op;
                writer.u8(72);
                this.encodeId(operation.obj);
                this.encodeId(operation.val);
                break;
            }
            case operations.InsObjOp: {
                const operation = op;
                const data = operation.data;
                const length = data.length;
                if (length <= 0b111) {
                    writer.u8(80 + length);
                }
                else {
                    writer.u8(80);
                    writer.vu57(length);
                }
                this.encodeId(operation.obj);
                for (let i = 0; i < length; i++) {
                    const tuple = data[i];
                    this.writeStr(tuple[0]);
                    this.encodeId(tuple[1]);
                }
                break;
            }
            case operations.InsVecOp: {
                const operation = op;
                const data = operation.data;
                const length = data.length;
                if (length <= 0b111) {
                    writer.u8(88 + length);
                }
                else {
                    writer.u8(88);
                    writer.vu57(length);
                }
                this.encodeId(operation.obj);
                for (let i = 0; i < length; i++) {
                    const tuple = data[i];
                    writer.u8(tuple[0]);
                    this.encodeId(tuple[1]);
                }
                break;
            }
            case operations.InsStrOp: {
                const operation = op;
                const obj = operation.obj;
                const ref = operation.ref;
                const str = operation.data;
                const len1 = str.length;
                writer.ensureCapacity(24 + len1 * 4);
                const x = writer.x;
                const len2 = this.writeInsStr(len1, obj, ref, str);
                if (len1 !== len2) {
                    writer.x = x;
                    this.writeInsStr(len2, obj, ref, str);
                }
                break;
            }
            case operations.InsBinOp: {
                const operation = op;
                const buf = operation.data;
                const length = buf.length;
                if (length <= 0b111) {
                    writer.u8(104 + length);
                }
                else {
                    writer.u8(104);
                    writer.vu57(length);
                }
                this.encodeId(operation.obj);
                this.encodeId(operation.ref);
                writer.buf(buf, length);
                break;
            }
            case operations.InsArrOp: {
                const operation = op;
                const elements = operation.data;
                const length = elements.length;
                if (length <= 0b111) {
                    writer.u8(112 + length);
                }
                else {
                    writer.u8(112);
                    writer.vu57(length);
                }
                this.encodeId(operation.obj);
                this.encodeId(operation.ref);
                for (let i = 0; i < length; i++)
                    this.encodeId(elements[i]);
                break;
            }
            case operations.DelOp: {
                const operation = op;
                const what = operation.what;
                const length = what.length;
                if (length <= 0b111) {
                    writer.u8(128 + length);
                }
                else {
                    writer.u8(128);
                    writer.vu57(length);
                }
                this.encodeId(operation.obj);
                for (let i = 0; i < length; i++)
                    this.encodeTss(what[i]);
                break;
            }
            case operations.NopOp: {
                const operation = op;
                const length = operation.len;
                if (length <= 0b111) {
                    writer.u8(136 + length);
                }
                else {
                    writer.u8(136);
                    writer.vu57(length);
                }
                break;
            }
            default: {
                throw new Error('UNKNOWN_OP');
            }
        }
    }
}
