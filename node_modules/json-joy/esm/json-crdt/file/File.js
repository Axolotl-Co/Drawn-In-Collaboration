import { PatchLog } from './PatchLog';
import { Encoder as SidecarEncoder } from '../codec/sidecar/binary/Encoder';
import { Decoder as SidecarDecoder } from '../codec/sidecar/binary/Decoder';
import { Encoder as StructuralEncoderCompact } from '../codec/structural/compact/Encoder';
import { Encoder as StructuralEncoderVerbose } from '../codec/structural/verbose/Encoder';
import { encode as encodeCompact } from '../../json-crdt-patch/codec/compact/encode';
import { encode as encodeVerbose } from '../../json-crdt-patch/codec/verbose/encode';
import { Writer } from '../../util/buffers/Writer';
import { CborEncoder } from '../../json-pack/cbor/CborEncoder';
import { JsonEncoder } from '../../json-pack/json/JsonEncoder';
import { printTree } from '../../util/print/printTree';
import { decodeModel, decodeNdjsonComponents, decodePatch, decodeSeqCborComponents } from './util';
export class File {
    model;
    log;
    static unserialize(components) {
        const [view, metadata, model, history, ...frontier] = components;
        const modelFormat = metadata[1];
        let decodedModel = null;
        if (model) {
            const isSidecar = modelFormat === 1;
            if (isSidecar) {
                const decoder = new SidecarDecoder();
                if (!(model instanceof Uint8Array))
                    throw new Error('NOT_BLOB');
                decodedModel = decoder.decode(view, model);
            }
            else {
                decodedModel = decodeModel(model);
            }
        }
        let log = null;
        if (history) {
            const [start, patches] = history;
            if (start) {
                const startModel = decodeModel(start);
                log = new PatchLog(startModel);
                for (const patch of patches)
                    log.push(decodePatch(patch));
            }
        }
        if (!log)
            throw new Error('NO_HISTORY');
        if (!decodedModel)
            decodedModel = log.replayToEnd();
        if (frontier.length) {
            for (const patch of frontier) {
                const patchDecoded = decodePatch(patch);
                decodedModel.applyPatch(patchDecoded);
                log.push(patchDecoded);
            }
        }
        const file = new File(decodedModel, log);
        return file;
    }
    static fromNdjson(blob) {
        const components = decodeNdjsonComponents(blob);
        return File.unserialize(components);
    }
    static fromSeqCbor(blob) {
        const components = decodeSeqCborComponents(blob);
        return File.unserialize(components);
    }
    static fromModel(model) {
        return new File(model, PatchLog.fromModel(model));
    }
    constructor(model, log) {
        this.model = model;
        this.log = log;
    }
    apply(patch) {
        const id = patch.getId();
        if (!id)
            return;
        this.model.applyPatch(patch);
        this.log.push(patch);
    }
    sync() {
        const { model, log } = this;
        const api = model.api;
        const autoflushUnsubscribe = api.autoFlush();
        const onPatchUnsubscribe = api.onPatch.listen((patch) => {
            log.push(patch);
        });
        const onFlushUnsubscribe = api.onFlush.listen((patch) => {
            log.push(patch);
        });
        return () => {
            autoflushUnsubscribe();
            onPatchUnsubscribe();
            onFlushUnsubscribe();
        };
    }
    serialize(params = {}) {
        if (params.noView && params.model === 'sidecar')
            throw new Error('SIDECAR_MODEL_WITHOUT_VIEW');
        const metadata = [{}, 0];
        let model = null;
        const modelFormat = params.model ?? 'sidecar';
        switch (modelFormat) {
            case 'sidecar': {
                metadata[1] = 1;
                const encoder = new SidecarEncoder();
                const [, uint8] = encoder.encode(this.model);
                model = uint8;
                break;
            }
            case 'binary': {
                model = this.model.toBinary();
                break;
            }
            case 'compact': {
                model = new StructuralEncoderCompact().encode(this.model);
                break;
            }
            case 'verbose': {
                model = new StructuralEncoderVerbose().encode(this.model);
                break;
            }
            case 'none': {
                model = null;
                break;
            }
            default:
                throw new Error(`Invalid model format: ${modelFormat}`);
        }
        const history = [null, []];
        const patchFormat = params.history ?? 'binary';
        switch (patchFormat) {
            case 'binary': {
                history[0] = this.log.start.toBinary();
                this.log.patches.forEach(({ v }) => {
                    history[1].push(v.toBinary());
                });
                break;
            }
            case 'compact': {
                history[0] = new StructuralEncoderCompact().encode(this.log.start);
                this.log.patches.forEach(({ v }) => {
                    history[1].push(encodeCompact(v));
                });
                break;
            }
            case 'verbose': {
                history[0] = new StructuralEncoderVerbose().encode(this.log.start);
                this.log.patches.forEach(({ v }) => {
                    history[1].push(encodeVerbose(v));
                });
                break;
            }
            case 'none': {
                break;
            }
            default:
                throw new Error(`Invalid history format: ${patchFormat}`);
        }
        return [params.noView ? null : this.model.view(), metadata, model, history];
    }
    toBinary(params) {
        const sequence = this.serialize(params);
        const writer = new Writer(16 * 1024);
        switch (params.format) {
            case 'ndjson': {
                const json = new JsonEncoder(writer);
                for (const component of sequence) {
                    json.writeAny(component);
                    json.writer.u8('\n'.charCodeAt(0));
                }
                return json.writer.flush();
            }
            case 'seq.cbor': {
                const cbor = new CborEncoder(writer);
                for (const component of sequence)
                    cbor.writeAny(component);
                return cbor.writer.flush();
            }
        }
    }
    toString(tab) {
        return `file` + printTree(tab, [(tab) => this.model.toString(tab), () => '', (tab) => this.log.toString(tab)]);
    }
}
