import { Value } from './Value';
import { toText } from '../json-type/typescript/toText';
import { TypeSystem } from '../json-type/system/TypeSystem';
export class ObjectValue extends Value {
    static create = (system = new TypeSystem()) => new ObjectValue(system.t.obj, {});
    get system() {
        return this.type.getSystem();
    }
    get t() {
        return this.system.t;
    }
    keys() {
        const type = this.type;
        return type.fields.map((field) => field.key);
    }
    get(key) {
        const field = this.type.getField(key);
        if (!field)
            throw new Error('NO_FIELD');
        const type = field.value;
        const data = this.data[key];
        return new Value(type, data);
    }
    field(field, data) {
        field = typeof field === 'function' ? field(this.type.getSystem().t) : field;
        const extendedData = { ...this.data, [field.key]: data };
        const type = this.type;
        const system = type.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        const extendedType = system.t.Object(...type.fields, field);
        return new ObjectValue(extendedType, extendedData);
    }
    prop(key, type, data) {
        const system = this.type.getSystem();
        const t = system.t;
        type = typeof type === 'function' ? type(t) : type;
        return this.field(t.prop(key, type), data);
    }
    merge(obj) {
        const extendedData = { ...this.data, ...obj.data };
        const type = this.type;
        const system = type.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        const extendedType = system.t.Object(...type.fields, ...obj.type.fields);
        return new ObjectValue(extendedType, extendedData);
    }
    extend(inp) {
        const system = this.type.getSystem();
        const r = (key, val, data) => [key, val, data];
        const extension = inp(system.t, r, system);
        const type = this.type;
        const extendedFields = [...type.fields];
        const extendedData = { ...this.data };
        for (const [key, val, data] of extension) {
            extendedFields.push(system.t.prop(key, val));
            extendedData[key] = data;
        }
        const extendedType = system.t.Object(...extendedFields);
        return new ObjectValue(extendedType, extendedData);
    }
    toTypeScriptAst() {
        const node = {
            node: 'TypeLiteral',
            members: [],
        };
        const data = this.data;
        for (const [name, type] of Object.entries(data)) {
            const schema = type.getSchema();
            const property = {
                node: 'PropertySignature',
                name,
                type: type.toTypeScriptAst(),
            };
            if (schema.title)
                property.comment = schema.title;
            node.members.push(property);
        }
        return node;
    }
    toTypeScriptModuleAst() {
        const node = {
            node: 'ModuleDeclaration',
            name: 'Router',
            export: true,
            statements: [
                {
                    node: 'TypeAliasDeclaration',
                    name: 'Routes',
                    type: this.toTypeScriptAst(),
                    export: true,
                },
            ],
        };
        const system = this.type.system;
        if (!system)
            throw new Error('system is undefined');
        for (const alias of system.aliases.values())
            node.statements.push({ ...alias.toTypeScriptAst(), export: true });
        return node;
    }
    toTypeScript() {
        return toText(this.toTypeScriptModuleAst());
    }
}
