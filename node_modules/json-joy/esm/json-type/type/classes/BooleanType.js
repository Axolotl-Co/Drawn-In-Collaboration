import { RandomJson } from '../../../json-random';
import { validateTType } from '../../schema/validate';
import { ValidationError } from '../../constants';
import { AbstractType } from './AbstractType';
export class BooleanType extends AbstractType {
    schema;
    constructor(schema) {
        super();
        this.schema = schema;
    }
    toJsonSchema(ctx) {
        return {
            type: 'boolean',
            ...super.toJsonSchema(ctx),
        };
    }
    validateSchema() {
        validateTType(this.getSchema(), 'bool');
    }
    codegenValidator(ctx, path, r) {
        const err = ctx.err(ValidationError.BOOL, path);
        ctx.js(`if(typeof ${r} !== "boolean") return ${err};`);
        ctx.emitCustomValidators(this, path, r);
    }
    codegenJsonTextEncoder(ctx, value) {
        ctx.js(`s += ${value.use()} ? 'true' : 'false';`);
    }
    codegenBinaryEncoder(ctx, value) {
        ctx.js(`encoder.writeBoolean(${value.use()});`);
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        ctx.inc(5);
    }
    random() {
        return RandomJson.genBoolean();
    }
    toTypeScriptAst() {
        return { node: 'BooleanKeyword' };
    }
    toJson(value, system = this.system) {
        return (value ? 'true' : 'false');
    }
    toJtdForm() {
        const form = { type: 'boolean' };
        return form;
    }
}
