import * as schema from '../../schema';
import { printTree } from '../../../util/print/printTree';
import { validateTType } from '../../schema/validate';
import { AbstractType } from './AbstractType';
const fnNotImplemented = async () => {
    throw new Error('NOT_IMPLEMENTED');
};
export class FunctionType extends AbstractType {
    req;
    res;
    schema;
    fn = fnNotImplemented;
    constructor(req, res, options) {
        super();
        this.req = req;
        this.res = res;
        this.schema = {
            ...options,
            ...schema.s.Function(schema.s.any, schema.s.any),
        };
    }
    getSchema() {
        return {
            ...this.schema,
            req: this.req.getSchema(),
            res: this.res.getSchema(),
        };
    }
    validateSchema() {
        const schema = this.getSchema();
        validateTType(schema, 'fn');
        this.req.validateSchema();
        this.res.validateSchema();
    }
    random() {
        return async () => this.res.random();
    }
    singleton = undefined;
    implement(singleton) {
        this.singleton = singleton;
        return this;
    }
    toTypeScriptAst() {
        const node = {
            node: 'FunctionType',
            parameters: [
                {
                    node: 'Parameter',
                    name: {
                        node: 'Identifier',
                        name: 'request',
                    },
                    type: this.req.toTypeScriptAst(),
                },
            ],
            type: {
                node: 'TypeReference',
                typeName: {
                    node: 'Identifier',
                    name: 'Promise',
                },
                typeArguments: [this.res.toTypeScriptAst()],
            },
        };
        return node;
    }
    toString(tab = '') {
        return (super.toString(tab) +
            printTree(tab, [(tab) => 'req: ' + this.req.toString(tab), (tab) => 'res: ' + this.res.toString(tab)]));
    }
}
export class FunctionStreamingType extends AbstractType {
    req;
    res;
    isStreaming = true;
    schema;
    constructor(req, res, options) {
        super();
        this.req = req;
        this.res = res;
        this.schema = {
            ...options,
            ...schema.s.Function$(schema.s.any, schema.s.any),
        };
    }
    getSchema() {
        return {
            ...this.schema,
            req: this.req.getSchema(),
            res: this.res.getSchema(),
        };
    }
    validateSchema() {
        const schema = this.getSchema();
        validateTType(schema, 'fn$');
        this.req.validateSchema();
        this.res.validateSchema();
    }
    random() {
        return async () => this.res.random();
    }
    singleton = undefined;
    implement(singleton) {
        this.singleton = singleton;
        return this;
    }
    toTypeScriptAst() {
        const node = {
            node: 'FunctionType',
            parameters: [
                {
                    node: 'Parameter',
                    name: {
                        node: 'Identifier',
                        name: 'request$',
                    },
                    type: {
                        node: 'TypeReference',
                        typeName: {
                            node: 'Identifier',
                            name: 'Observable',
                        },
                        typeArguments: [this.req.toTypeScriptAst()],
                    },
                },
            ],
            type: {
                node: 'TypeReference',
                typeName: {
                    node: 'Identifier',
                    name: 'Observable',
                },
                typeArguments: [this.res.toTypeScriptAst()],
            },
        };
        return node;
    }
    toString(tab = '') {
        return (super.toString(tab) +
            printTree(tab, [(tab) => 'req: ' + this.req.toString(tab), (tab) => 'res: ' + this.res.toString(tab)]));
    }
}
