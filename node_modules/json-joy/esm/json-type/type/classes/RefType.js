import * as schema from '../../schema';
import { validateTType } from '../../schema/validate';
import { ValidationError } from '../../constants';
import { CborEncoderCodegenContext } from '../../codegen/binary/CborEncoderCodegenContext';
import { JsonEncoderCodegenContext } from '../../codegen/binary/JsonEncoderCodegenContext';
import { MessagePackEncoderCodegenContext } from '../../codegen/binary/MessagePackEncoderCodegenContext';
import { AbstractType } from './AbstractType';
export class RefType extends AbstractType {
    schema;
    constructor(ref) {
        super();
        this.schema = schema.s.Ref(ref);
    }
    getRef() {
        return this.schema.ref;
    }
    toJsonSchema(ctx) {
        const ref = this.schema.ref;
        if (ctx)
            ctx.mentionRef(ref);
        const jsonSchema = {
            $ref: `#/$defs/${ref}`,
            ...super.toJsonSchema(ctx),
        };
        return jsonSchema;
    }
    getOptions() {
        const { __t, ref, ...options } = this.schema;
        return options;
    }
    validateSchema() {
        const schema = this.getSchema();
        validateTType(schema, 'ref');
        const { ref } = schema;
        if (typeof ref !== 'string')
            throw new Error('REF_TYPE');
        if (!ref)
            throw new Error('REF_EMPTY');
    }
    codegenValidator(ctx, path, r) {
        const refErr = (errorRegister) => {
            switch (ctx.options.errors) {
                case 'boolean':
                    return errorRegister;
                case 'string': {
                    return ctx.err(ValidationError.REF, [...path, { r: errorRegister }]);
                }
                case 'object':
                default: {
                    return ctx.err(ValidationError.REF, [...path], { refId: this.schema.ref, refError: errorRegister });
                }
            }
        };
        const system = ctx.options.system || this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        const validator = system.resolve(this.schema.ref).type.validator(ctx.options.errors);
        const d = ctx.codegen.linkDependency(validator);
        const rerr = ctx.codegen.getRegister();
        ctx.js(`var ${rerr} = ${d}(${r});`);
        ctx.js(`if (${rerr}) return ${refErr(rerr)};`);
    }
    codegenJsonTextEncoder(ctx, value) {
        const system = ctx.options.system || this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        const encoder = system.resolve(this.schema.ref).type.jsonTextEncoder();
        const d = ctx.codegen.linkDependency(encoder);
        ctx.js(`s += ${d}(${value.use()});`);
    }
    codegenBinaryEncoder(ctx, value) {
        const system = ctx.options.system || this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        const kind = ctx instanceof CborEncoderCodegenContext
            ? 0
            : ctx instanceof MessagePackEncoderCodegenContext
                ? 1
                : 2;
        const targetType = system.resolve(this.schema.ref).type;
        switch (targetType.getTypeName()) {
            case 'str':
            case 'bool':
            case 'num':
            case 'any':
            case 'tup': {
                if (ctx instanceof CborEncoderCodegenContext)
                    targetType.codegenCborEncoder(ctx, value);
                else if (ctx instanceof MessagePackEncoderCodegenContext)
                    targetType.codegenMessagePackEncoder(ctx, value);
                else if (ctx instanceof JsonEncoderCodegenContext)
                    targetType.codegenJsonEncoder(ctx, value);
                break;
            }
            default: {
                const encoder = targetType.encoder(kind);
                const d = ctx.codegen.linkDependency(encoder);
                ctx.js(`${d}(${value.use()}, encoder);`);
            }
        }
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        const system = ctx.options.system || this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        const estimator = system.resolve(this.schema.ref).type.capacityEstimator();
        const d = ctx.codegen.linkDependency(estimator);
        ctx.codegen.js(`size += ${d}(${value.use()});`);
    }
    random() {
        if (!this.system)
            throw new Error('NO_SYSTEM');
        const alias = this.system.resolve(this.schema.ref);
        return alias.type.random();
    }
    toTypeScriptAst() {
        return {
            node: 'GenericTypeAnnotation',
            id: {
                node: 'Identifier',
                name: this.schema.ref,
            },
        };
    }
    toJson(value, system = this.system) {
        if (!system)
            return 'null';
        const alias = system.resolve(this.schema.ref);
        return alias.type.toJson(value, system);
    }
    toStringTitle(tab = '') {
        const options = this.toStringOptions();
        return `${super.toStringTitle()} â†’ [${this.schema.ref}]` + (options ? ` ${options}` : '');
    }
}
