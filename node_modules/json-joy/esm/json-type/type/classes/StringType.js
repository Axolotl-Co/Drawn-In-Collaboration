import { RandomJson } from '../../../json-random';
import { asString } from '../../../util/strings/asString';
import { validateMinMax, validateTType, validateWithValidator } from '../../schema/validate';
import { ValidationError } from '../../constants';
import { AbstractType } from './AbstractType';
export class StringType extends AbstractType {
    schema;
    constructor(schema) {
        super();
        this.schema = schema;
    }
    toJsonSchema(ctx) {
        const schema = this.getSchema();
        const jsonSchema = {
            type: 'string',
            ...super.toJsonSchema(ctx),
        };
        if (schema.min !== undefined)
            jsonSchema.minLength = schema.min;
        if (schema.max !== undefined)
            jsonSchema.maxLength = schema.max;
        return jsonSchema;
    }
    validateSchema() {
        const schema = this.getSchema();
        validateTType(schema, 'str');
        validateWithValidator(schema);
        const { min, max, ascii, noJsonEscape } = schema;
        validateMinMax(min, max);
        if (ascii !== undefined) {
            if (typeof ascii !== 'boolean')
                throw new Error('ASCII');
        }
        if (noJsonEscape !== undefined) {
            if (typeof noJsonEscape !== 'boolean')
                throw new Error('NO_JSON_ESCAPE_TYPE');
        }
    }
    codegenValidator(ctx, path, r) {
        const error = ctx.err(ValidationError.STR, path);
        ctx.js(`if(typeof ${r} !== "string") return ${error};`);
        const { min, max } = this.schema;
        if (typeof min === 'number' && min === max) {
            const err = ctx.err(ValidationError.STR_LEN, path);
            ctx.js(`if(${r}.length !== ${min}) return ${err};`);
        }
        else {
            if (typeof min === 'number') {
                const err = ctx.err(ValidationError.STR_LEN, path);
                ctx.js(`if(${r}.length < ${min}) return ${err};`);
            }
            if (typeof max === 'number') {
                const err = ctx.err(ValidationError.STR_LEN, path);
                ctx.js(`if(${r}.length > ${max}) return ${err};`);
            }
        }
        ctx.emitCustomValidators(this, path, r);
    }
    codegenJsonTextEncoder(ctx, value) {
        if (this.schema.noJsonEscape) {
            ctx.writeText('"');
            ctx.js(`s += ${value.use()};`);
            ctx.writeText('"');
        }
        else
            ctx.js(`s += asString(${value.use()});`);
    }
    codegenBinaryEncoder(ctx, value) {
        const ascii = this.schema.ascii;
        const v = value.use();
        if (ascii)
            ctx.js(`encoder.writeAsciiStr(${v});`);
        else
            ctx.js(`encoder.writeStr(${v});`);
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        ctx.inc(5);
        ctx.codegen.js(`size += ${5} * ${value.use()}.length;`);
    }
    random() {
        let length = Math.round(Math.random() * 10);
        const { min, max } = this.schema;
        if (min !== undefined && length < min)
            length = min + length;
        if (max !== undefined && length > max)
            length = max;
        return RandomJson.genString(length);
    }
    toTypeScriptAst() {
        return { node: 'StringKeyword' };
    }
    toJson(value, system = this.system) {
        return (this.schema.noJsonEscape ? '"' + value + '"' : asString(value));
    }
    toJtdForm() {
        return { type: 'string' };
    }
}
