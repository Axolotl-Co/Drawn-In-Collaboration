import { RandomJson } from '../../../json-random';
import { stringify } from '../../../json-text/stringify';
import { ValidatorCodegenContext } from '../../codegen/validator/ValidatorCodegenContext';
import { JsonTextEncoderCodegenContext, } from '../../codegen/json/JsonTextEncoderCodegenContext';
import { CborEncoderCodegenContext, } from '../../codegen/binary/CborEncoderCodegenContext';
import { JsonEncoderCodegenContext, } from '../../codegen/binary/JsonEncoderCodegenContext';
import { CborEncoder } from '../../../json-pack/cbor/CborEncoder';
import { JsExpression } from '../../../util/codegen/util/JsExpression';
import { MessagePackEncoderCodegenContext, } from '../../codegen/binary/MessagePackEncoderCodegenContext';
import { MsgPackEncoder } from '../../../json-pack/msgpack';
import { lazy } from '../../../util/lazyFunction';
import { JsonEncoder } from '../../../json-pack/json/JsonEncoder';
import { Writer } from '../../../util/buffers/Writer';
import { CapacityEstimatorCodegenContext, } from '../../codegen/capacity/CapacityEstimatorCodegenContext';
export class AbstractType {
    system;
    validators = {};
    encoders = new Map();
    getSystem() {
        const system = this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        return system;
    }
    getTypeName() {
        return this.schema.__t;
    }
    getSchema() {
        return this.schema;
    }
    getValidatorNames() {
        const { validator } = this.schema;
        if (!validator)
            return [];
        return Array.isArray(validator) ? validator : [validator];
    }
    toJsonSchema(ctx) {
        const schema = this.getSchema();
        const jsonSchema = {};
        if (schema.title)
            jsonSchema.title = schema.title;
        if (schema.description)
            jsonSchema.description = schema.description;
        if (schema.examples)
            jsonSchema.examples = schema.examples.map((example) => example.value);
        return jsonSchema;
    }
    options(options) {
        Object.assign(this.schema, options);
        return this;
    }
    getOptions() {
        const { __t, ...options } = this.schema;
        return options;
    }
    validate(value) {
        const validator = this.validator('string');
        const err = validator(value);
        if (err)
            throw new Error(JSON.parse(err)[0]);
    }
    compileValidator(options) {
        const ctx = new ValidatorCodegenContext({
            system: this.system,
            errors: 'object',
            ...options,
            type: this,
        });
        this.codegenValidator(ctx, [], ctx.codegen.options.args[0]);
        return ctx.compile();
    }
    __compileValidator(kind) {
        return (this.validators[kind] = this.compileValidator({
            errors: kind,
            system: this.system,
            skipObjectExtraFieldsCheck: kind === 'boolean',
            unsafeMode: kind === 'boolean',
        }));
    }
    validator(kind) {
        return this.validators[kind] || lazy(() => this.__compileValidator(kind));
    }
    compileJsonTextEncoder(options) {
        const ctx = new JsonTextEncoderCodegenContext({
            ...options,
            system: this.system,
            type: this,
        });
        const r = ctx.codegen.options.args[0];
        const value = new JsExpression(() => r);
        this.codegenJsonTextEncoder(ctx, value);
        return ctx.compile();
    }
    codegenJsonTextEncoder(ctx, value) {
        throw new Error(`${this.constructor.name}.codegenJsonTextEncoder() not implemented`);
    }
    __jsonEncoder;
    jsonTextEncoder() {
        return (this.__jsonEncoder || (this.__jsonEncoder = lazy(() => (this.__jsonEncoder = this.compileJsonTextEncoder({})))));
    }
    compileEncoder(format, name) {
        switch (format) {
            case 0: {
                const encoder = this.compileCborEncoder({ name });
                this.encoders.set(0, encoder);
                return encoder;
            }
            case 1: {
                const encoder = this.compileMessagePackEncoder({ name });
                this.encoders.set(1, encoder);
                return encoder;
            }
            case 2: {
                const encoder = this.compileJsonEncoder({ name });
                this.encoders.set(2, encoder);
                return encoder;
            }
            default:
                throw new Error(`Unsupported encoding format: ${format}`);
        }
    }
    encoder(kind) {
        const encoders = this.encoders;
        const cachedEncoder = encoders.get(kind);
        if (cachedEncoder)
            return cachedEncoder;
        const temporaryWrappedEncoder = lazy(() => this.compileEncoder(kind));
        encoders.set(kind, temporaryWrappedEncoder);
        return temporaryWrappedEncoder;
    }
    encode(codec, value) {
        const encoder = this.encoder(codec.format);
        const writer = codec.encoder.writer;
        writer.reset();
        encoder(value, codec.encoder);
        return writer.flush();
    }
    codegenValidator(ctx, path, r) {
        throw new Error(`${this.constructor.name}.codegenValidator() not implemented`);
    }
    compileCborEncoder(options) {
        const ctx = new CborEncoderCodegenContext({
            system: this.system,
            encoder: new CborEncoder(),
            ...options,
            type: this,
        });
        const r = ctx.codegen.options.args[0];
        const value = new JsExpression(() => r);
        this.codegenCborEncoder(ctx, value);
        return ctx.compile();
    }
    codegenCborEncoder(ctx, value) {
        throw new Error(`${this.constructor.name}.codegenCborEncoder() not implemented`);
    }
    compileMessagePackEncoder(options) {
        const ctx = new MessagePackEncoderCodegenContext({
            system: this.system,
            encoder: new MsgPackEncoder(),
            ...options,
            type: this,
        });
        const r = ctx.codegen.options.args[0];
        const value = new JsExpression(() => r);
        this.codegenMessagePackEncoder(ctx, value);
        return ctx.compile();
    }
    codegenMessagePackEncoder(ctx, value) {
        throw new Error(`${this.constructor.name}.codegenMessagePackEncoder() not implemented`);
    }
    compileJsonEncoder(options) {
        const writer = new Writer();
        const ctx = new JsonEncoderCodegenContext({
            system: this.system,
            encoder: new JsonEncoder(writer),
            ...options,
            type: this,
        });
        const r = ctx.codegen.options.args[0];
        const value = new JsExpression(() => r);
        this.codegenJsonEncoder(ctx, value);
        return ctx.compile();
    }
    codegenJsonEncoder(ctx, value) {
        throw new Error(`${this.constructor.name}.codegenJsonEncoder() not implemented`);
    }
    compileCapacityEstimator(options) {
        const ctx = new CapacityEstimatorCodegenContext({
            system: this.system,
            ...options,
            type: this,
        });
        const r = ctx.codegen.options.args[0];
        const value = new JsExpression(() => r);
        this.codegenCapacityEstimator(ctx, value);
        return ctx.compile();
    }
    codegenCapacityEstimator(ctx, value) {
        throw new Error(`${this.constructor.name}.codegenCapacityEstimator() not implemented`);
    }
    __capacityEstimator;
    capacityEstimator() {
        return (this.__capacityEstimator ||
            (this.__capacityEstimator = lazy(() => (this.__capacityEstimator = this.compileCapacityEstimator({})))));
    }
    random() {
        return RandomJson.generate({ nodeCount: 5 });
    }
    toTypeScriptAst() {
        const node = { node: 'UnknownKeyword' };
        return node;
    }
    toJson(value, system = this.system) {
        return JSON.stringify(value);
    }
    toStringTitle() {
        return this.getTypeName();
    }
    toStringOptions() {
        const options = this.getOptions();
        if (Object.keys(options).length === 0)
            return '';
        return stringify(options);
    }
    toString(tab = '') {
        const options = this.toStringOptions();
        return this.toStringTitle() + (options ? ` ${options}` : '');
    }
    toJtdForm() {
        const form = { nullable: false };
        return form;
    }
}
