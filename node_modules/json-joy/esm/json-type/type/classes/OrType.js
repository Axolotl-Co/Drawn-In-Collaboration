import * as schema from '../../schema';
import { printTree } from '../../../util/print/printTree';
import { validateTType } from '../../schema/validate';
import { ValidationError } from '../../constants';
import { CborEncoderCodegenContext } from '../../codegen/binary/CborEncoderCodegenContext';
import { JsonEncoderCodegenContext } from '../../codegen/binary/JsonEncoderCodegenContext';
import { MessagePackEncoderCodegenContext } from '../../codegen/binary/MessagePackEncoderCodegenContext';
import { JsonExpressionCodegen } from '../../../json-expression';
import { operatorsMap } from '../../../json-expression/operators';
import { Vars } from '../../../json-expression/Vars';
import { Discriminator } from '../discriminator';
import { AbstractType } from './AbstractType';
export class OrType extends AbstractType {
    types;
    schema;
    constructor(types, options) {
        super();
        this.types = types;
        this.schema = {
            ...schema.s.Or(),
            ...options,
            discriminator: options?.discriminator ?? Discriminator.createExpression(types),
        };
    }
    getSchema() {
        return {
            ...this.schema,
            types: this.types.map((type) => type.getSchema()),
        };
    }
    toJsonSchema(ctx) {
        return {
            anyOf: this.types.map((type) => type.toJsonSchema(ctx)),
        };
    }
    getOptions() {
        const { __t, types, ...options } = this.schema;
        return options;
    }
    options(options) {
        Object.assign(this.schema, options);
        return this;
    }
    __discriminator = undefined;
    discriminator() {
        if (this.__discriminator)
            return this.__discriminator;
        const expr = this.schema.discriminator;
        if (!expr || (expr[0] === 'num' && expr[1] === 0))
            throw new Error('NO_DISCRIMINATOR');
        const codegen = new JsonExpressionCodegen({
            expression: expr,
            operators: operatorsMap,
        });
        const fn = codegen.run().compile();
        return (this.__discriminator = (data) => +fn({ vars: new Vars(data) }));
    }
    validateSchema() {
        const schema = this.getSchema();
        validateTType(schema, 'or');
        const { types, discriminator } = schema;
        if (!discriminator || (discriminator[0] === 'num' && discriminator[1] === -1))
            throw new Error('DISCRIMINATOR');
        if (!Array.isArray(types))
            throw new Error('TYPES_TYPE');
        if (!types.length)
            throw new Error('TYPES_LENGTH');
        for (const type of this.types)
            type.validateSchema();
    }
    codegenValidator(ctx, path, r) {
        const types = this.types;
        const codegen = ctx.codegen;
        const length = types.length;
        if (length === 1) {
            types[0].codegenValidator(ctx, path, r);
            return;
        }
        const discriminator = this.discriminator();
        const d = codegen.linkDependency(discriminator);
        codegen.switch(`${d}(${r})`, types.map((type, index) => [
            index,
            () => {
                type.codegenValidator(ctx, path, r);
            },
        ]), () => {
            const err = ctx.err(ValidationError.OR, path);
            ctx.js(`return ${err}`);
        });
    }
    codegenJsonTextEncoder(ctx, value) {
        ctx.js(`s += stringify(${value.use()});`);
    }
    codegenBinaryEncoder(ctx, value) {
        const codegen = ctx.codegen;
        const discriminator = this.discriminator();
        const d = codegen.linkDependency(discriminator);
        const types = this.types;
        codegen.switch(`${d}(${value.use()})`, types.map((type, index) => [
            index,
            () => {
                if (ctx instanceof CborEncoderCodegenContext)
                    type.codegenCborEncoder(ctx, value);
                else if (ctx instanceof MessagePackEncoderCodegenContext)
                    type.codegenMessagePackEncoder(ctx, value);
                else if (ctx instanceof JsonEncoderCodegenContext)
                    type.codegenJsonEncoder(ctx, value);
            },
        ]));
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        const codegen = ctx.codegen;
        const discriminator = this.discriminator();
        const d = codegen.linkDependency(discriminator);
        const types = this.types;
        codegen.switch(`${d}(${value.use()})`, types.map((type, index) => [
            index,
            () => {
                type.codegenCapacityEstimator(ctx, value);
            },
        ]));
    }
    random() {
        const types = this.types;
        const index = Math.floor(Math.random() * types.length);
        return types[index].random();
    }
    toTypeScriptAst() {
        const node = {
            node: 'UnionType',
            types: this.types.map((t) => t.toTypeScriptAst()),
        };
        return node;
    }
    toJson(value, system = this.system) {
        return JSON.stringify(value);
    }
    toString(tab = '') {
        return super.toString(tab) + printTree(tab, [...this.types.map((type) => (tab) => type.toString(tab))]);
    }
}
