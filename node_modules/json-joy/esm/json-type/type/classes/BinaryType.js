import * as schema from '../../schema';
import { RandomJson } from '../../../json-random';
import { stringifyBinary } from '../../../json-binary';
import { printTree } from '../../../util/print/printTree';
import { validateTType } from '../../schema/validate';
import { ValidationError } from '../../constants';
import { AbstractType } from './AbstractType';
export class BinaryType extends AbstractType {
    type;
    schema;
    constructor(type, options) {
        super();
        this.type = type;
        this.schema = schema.s.Binary(schema.s.any, options);
    }
    getSchema() {
        return {
            ...this.schema,
            type: this.type.getSchema(),
        };
    }
    toJsonSchema(ctx) {
        return {
            type: 'binary',
            ...super.toJsonSchema(ctx),
        };
    }
    getOptions() {
        const { __t, type, ...options } = this.schema;
        return options;
    }
    validateSchema() {
        validateTType(this.getSchema(), 'bin');
        this.type.validateSchema();
    }
    codegenValidator(ctx, path, r) {
        const hasBuffer = typeof Buffer === 'function';
        const err = ctx.err(ValidationError.BIN, path);
        ctx.js(`if(!(${r} instanceof Uint8Array)${hasBuffer ? ` && !Buffer.isBuffer(${r})` : ''}) return ${err};`);
        ctx.emitCustomValidators(this, path, r);
    }
    codegenJsonTextEncoder(ctx, value) {
        ctx.linkBase64();
        ctx.writeText('"data:application/octet-stream;base64,');
        ctx.js(`s += toBase64(${value.use()});`);
        ctx.writeText('"');
    }
    codegenBinaryEncoder(ctx, value) {
        ctx.js(`encoder.writeBin(${value.use()});`);
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        ctx.inc(41);
        ctx.codegen.js(`size += ${2} * ${value.use()}.length;`);
    }
    random() {
        const octets = RandomJson.genString()
            .split('')
            .map((c) => c.charCodeAt(0));
        return new Uint8Array(octets);
    }
    toTypeScriptAst() {
        return {
            node: 'GenericTypeAnnotation',
            id: {
                node: 'Identifier',
                name: 'Uint8Array',
            },
        };
    }
    toJson(value, system = this.system) {
        return ('"' + stringifyBinary(value) + '"');
    }
    toString(tab = '') {
        return super.toString(tab) + printTree(tab, [(tab) => this.type.toString(tab)]);
    }
}
