"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.File = void 0;
const PatchLog_1 = require("./PatchLog");
const Encoder_1 = require("../codec/sidecar/binary/Encoder");
const Decoder_1 = require("../codec/sidecar/binary/Decoder");
const Encoder_2 = require("../codec/structural/compact/Encoder");
const Encoder_3 = require("../codec/structural/verbose/Encoder");
const encode_1 = require("../../json-crdt-patch/codec/compact/encode");
const encode_2 = require("../../json-crdt-patch/codec/verbose/encode");
const Writer_1 = require("../../util/buffers/Writer");
const CborEncoder_1 = require("../../json-pack/cbor/CborEncoder");
const JsonEncoder_1 = require("../../json-pack/json/JsonEncoder");
const printTree_1 = require("../../util/print/printTree");
const util_1 = require("./util");
class File {
    static unserialize(components) {
        const [view, metadata, model, history, ...frontier] = components;
        const modelFormat = metadata[1];
        let decodedModel = null;
        if (model) {
            const isSidecar = modelFormat === 1;
            if (isSidecar) {
                const decoder = new Decoder_1.Decoder();
                if (!(model instanceof Uint8Array))
                    throw new Error('NOT_BLOB');
                decodedModel = decoder.decode(view, model);
            }
            else {
                decodedModel = (0, util_1.decodeModel)(model);
            }
        }
        let log = null;
        if (history) {
            const [start, patches] = history;
            if (start) {
                const startModel = (0, util_1.decodeModel)(start);
                log = new PatchLog_1.PatchLog(startModel);
                for (const patch of patches)
                    log.push((0, util_1.decodePatch)(patch));
            }
        }
        if (!log)
            throw new Error('NO_HISTORY');
        if (!decodedModel)
            decodedModel = log.replayToEnd();
        if (frontier.length) {
            for (const patch of frontier) {
                const patchDecoded = (0, util_1.decodePatch)(patch);
                decodedModel.applyPatch(patchDecoded);
                log.push(patchDecoded);
            }
        }
        const file = new File(decodedModel, log);
        return file;
    }
    static fromNdjson(blob) {
        const components = (0, util_1.decodeNdjsonComponents)(blob);
        return File.unserialize(components);
    }
    static fromSeqCbor(blob) {
        const components = (0, util_1.decodeSeqCborComponents)(blob);
        return File.unserialize(components);
    }
    static fromModel(model) {
        return new File(model, PatchLog_1.PatchLog.fromModel(model));
    }
    constructor(model, log) {
        this.model = model;
        this.log = log;
    }
    apply(patch) {
        const id = patch.getId();
        if (!id)
            return;
        this.model.applyPatch(patch);
        this.log.push(patch);
    }
    sync() {
        const { model, log } = this;
        const api = model.api;
        const autoflushUnsubscribe = api.autoFlush();
        const onPatchUnsubscribe = api.onPatch.listen((patch) => {
            log.push(patch);
        });
        const onFlushUnsubscribe = api.onFlush.listen((patch) => {
            log.push(patch);
        });
        return () => {
            autoflushUnsubscribe();
            onPatchUnsubscribe();
            onFlushUnsubscribe();
        };
    }
    serialize(params = {}) {
        if (params.noView && params.model === 'sidecar')
            throw new Error('SIDECAR_MODEL_WITHOUT_VIEW');
        const metadata = [{}, 0];
        let model = null;
        const modelFormat = params.model ?? 'sidecar';
        switch (modelFormat) {
            case 'sidecar': {
                metadata[1] = 1;
                const encoder = new Encoder_1.Encoder();
                const [, uint8] = encoder.encode(this.model);
                model = uint8;
                break;
            }
            case 'binary': {
                model = this.model.toBinary();
                break;
            }
            case 'compact': {
                model = new Encoder_2.Encoder().encode(this.model);
                break;
            }
            case 'verbose': {
                model = new Encoder_3.Encoder().encode(this.model);
                break;
            }
            case 'none': {
                model = null;
                break;
            }
            default:
                throw new Error(`Invalid model format: ${modelFormat}`);
        }
        const history = [null, []];
        const patchFormat = params.history ?? 'binary';
        switch (patchFormat) {
            case 'binary': {
                history[0] = this.log.start.toBinary();
                this.log.patches.forEach(({ v }) => {
                    history[1].push(v.toBinary());
                });
                break;
            }
            case 'compact': {
                history[0] = new Encoder_2.Encoder().encode(this.log.start);
                this.log.patches.forEach(({ v }) => {
                    history[1].push((0, encode_1.encode)(v));
                });
                break;
            }
            case 'verbose': {
                history[0] = new Encoder_3.Encoder().encode(this.log.start);
                this.log.patches.forEach(({ v }) => {
                    history[1].push((0, encode_2.encode)(v));
                });
                break;
            }
            case 'none': {
                break;
            }
            default:
                throw new Error(`Invalid history format: ${patchFormat}`);
        }
        return [params.noView ? null : this.model.view(), metadata, model, history];
    }
    toBinary(params) {
        const sequence = this.serialize(params);
        const writer = new Writer_1.Writer(16 * 1024);
        switch (params.format) {
            case 'ndjson': {
                const json = new JsonEncoder_1.JsonEncoder(writer);
                for (const component of sequence) {
                    json.writeAny(component);
                    json.writer.u8('\n'.charCodeAt(0));
                }
                return json.writer.flush();
            }
            case 'seq.cbor': {
                const cbor = new CborEncoder_1.CborEncoder(writer);
                for (const component of sequence)
                    cbor.writeAny(component);
                return cbor.writer.flush();
            }
        }
    }
    toString(tab) {
        return `file` + (0, printTree_1.printTree)(tab, [(tab) => this.model.toString(tab), () => '', (tab) => this.log.toString(tab)]);
    }
}
exports.File = File;
