"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcMessageBatchProcessor = void 0;
const tslib_1 = require("tslib");
const msg = tslib_1.__importStar(require("../messages"));
const caller_1 = require("./caller");
const validation_1 = require("./validation");
class RpcMessageBatchProcessor {
    constructor({ caller }) {
        this.caller = caller;
    }
    async onBatch(list, ctx) {
        try {
            const promises = [];
            const length = list.length;
            for (let i = 0; i < length; i++) {
                const message = list[i];
                switch (message.constructor) {
                    case msg.NotificationMessage:
                        this.onNotification(message, ctx);
                        break;
                    case msg.RequestDataMessage:
                    case msg.RequestCompleteMessage:
                    case msg.RequestErrorMessage:
                        promises.push(this.onRequest(message, ctx));
                        break;
                }
            }
            const settled = await Promise.allSettled(promises);
            const result = [];
            const settledLength = settled.length;
            for (let i = 0; i < settledLength; i++) {
                const item = settled[i];
                result.push(item.status === 'fulfilled' ? item.value : item.reason);
            }
            return result;
        }
        catch (error) {
            const value = caller_1.RpcError.internalErrorValue(error);
            return [new msg.ResponseErrorMessage(-1, value)];
        }
    }
    onNotification(message, ctx) {
        const method = message.method;
        (0, validation_1.validateMethod)(method);
        this.caller.notification(method, message.value.data, ctx).catch((error) => { });
    }
    async onRequest(message, ctx) {
        const id = message.id;
        (0, validation_1.validateId)(id);
        const method = message.method;
        (0, validation_1.validateMethod)(method);
        try {
            const value = message.value;
            const data = value ? value.data : undefined;
            const result = await this.caller.call(method, data, ctx);
            return new msg.ResponseCompleteMessage(id, result);
        }
        catch (error) {
            throw new msg.ResponseErrorMessage(id, error);
        }
    }
}
exports.RpcMessageBatchProcessor = RpcMessageBatchProcessor;
