"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionStreamingType = exports.FunctionType = void 0;
const tslib_1 = require("tslib");
const schema = tslib_1.__importStar(require("../../schema"));
const printTree_1 = require("../../../util/print/printTree");
const validate_1 = require("../../schema/validate");
const AbstractType_1 = require("./AbstractType");
const fnNotImplemented = async () => {
    throw new Error('NOT_IMPLEMENTED');
};
class FunctionType extends AbstractType_1.AbstractType {
    constructor(req, res, options) {
        super();
        this.req = req;
        this.res = res;
        this.fn = fnNotImplemented;
        this.singleton = undefined;
        this.schema = {
            ...options,
            ...schema.s.Function(schema.s.any, schema.s.any),
        };
    }
    getSchema() {
        return {
            ...this.schema,
            req: this.req.getSchema(),
            res: this.res.getSchema(),
        };
    }
    validateSchema() {
        const schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'fn');
        this.req.validateSchema();
        this.res.validateSchema();
    }
    random() {
        return async () => this.res.random();
    }
    implement(singleton) {
        this.singleton = singleton;
        return this;
    }
    toTypeScriptAst() {
        const node = {
            node: 'FunctionType',
            parameters: [
                {
                    node: 'Parameter',
                    name: {
                        node: 'Identifier',
                        name: 'request',
                    },
                    type: this.req.toTypeScriptAst(),
                },
            ],
            type: {
                node: 'TypeReference',
                typeName: {
                    node: 'Identifier',
                    name: 'Promise',
                },
                typeArguments: [this.res.toTypeScriptAst()],
            },
        };
        return node;
    }
    toString(tab = '') {
        return (super.toString(tab) +
            (0, printTree_1.printTree)(tab, [(tab) => 'req: ' + this.req.toString(tab), (tab) => 'res: ' + this.res.toString(tab)]));
    }
}
exports.FunctionType = FunctionType;
class FunctionStreamingType extends AbstractType_1.AbstractType {
    constructor(req, res, options) {
        super();
        this.req = req;
        this.res = res;
        this.isStreaming = true;
        this.singleton = undefined;
        this.schema = {
            ...options,
            ...schema.s.Function$(schema.s.any, schema.s.any),
        };
    }
    getSchema() {
        return {
            ...this.schema,
            req: this.req.getSchema(),
            res: this.res.getSchema(),
        };
    }
    validateSchema() {
        const schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'fn$');
        this.req.validateSchema();
        this.res.validateSchema();
    }
    random() {
        return async () => this.res.random();
    }
    implement(singleton) {
        this.singleton = singleton;
        return this;
    }
    toTypeScriptAst() {
        const node = {
            node: 'FunctionType',
            parameters: [
                {
                    node: 'Parameter',
                    name: {
                        node: 'Identifier',
                        name: 'request$',
                    },
                    type: {
                        node: 'TypeReference',
                        typeName: {
                            node: 'Identifier',
                            name: 'Observable',
                        },
                        typeArguments: [this.req.toTypeScriptAst()],
                    },
                },
            ],
            type: {
                node: 'TypeReference',
                typeName: {
                    node: 'Identifier',
                    name: 'Observable',
                },
                typeArguments: [this.res.toTypeScriptAst()],
            },
        };
        return node;
    }
    toString(tab = '') {
        return (super.toString(tab) +
            (0, printTree_1.printTree)(tab, [(tab) => 'req: ' + this.req.toString(tab), (tab) => 'res: ' + this.res.toString(tab)]));
    }
}
exports.FunctionStreamingType = FunctionStreamingType;
