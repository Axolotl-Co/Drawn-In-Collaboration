"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnyType = void 0;
const json_random_1 = require("../../../json-random");
const validate_1 = require("../../schema/validate");
const CborEncoderCodegenContext_1 = require("../../codegen/binary/CborEncoderCodegenContext");
const MessagePackEncoderCodegenContext_1 = require("../../codegen/binary/MessagePackEncoderCodegenContext");
const AbstractType_1 = require("./AbstractType");
class AnyType extends AbstractType_1.AbstractType {
    constructor(schema) {
        super();
        this.schema = schema;
    }
    toJsonSchema(ctx) {
        return {
            type: ['string', 'number', 'boolean', 'null', 'array', 'object'],
            ...super.toJsonSchema(ctx),
        };
    }
    validateSchema() {
        (0, validate_1.validateTType)(this.getSchema(), 'any');
    }
    codegenValidator(ctx, path, r) {
        ctx.emitCustomValidators(this, path, r);
    }
    codegenJsonTextEncoder(ctx, value) {
        ctx.js(`s += stringify(${value.use()});`);
    }
    codegenBinaryEncoder(ctx, value) {
        ctx.codegen.link('Value');
        const r = ctx.codegen.var(value.use());
        ctx.codegen.if(`${r} instanceof Value`, () => {
            ctx.codegen.if(`${r}.type`, () => {
                const type = ctx instanceof CborEncoderCodegenContext_1.CborEncoderCodegenContext
                    ? 0
                    : ctx instanceof MessagePackEncoderCodegenContext_1.MessagePackEncoderCodegenContext
                        ? 1
                        : 2;
                ctx.js(`${r}.type.encoder(${type})(${r}.data, encoder);`);
            }, () => {
                ctx.js(`encoder.writeAny(${r}.data);`);
            });
        }, () => {
            ctx.js(`encoder.writeAny(${r});`);
        });
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        const codegen = ctx.codegen;
        codegen.link('Value');
        const r = codegen.var(value.use());
        codegen.if(`${r} instanceof Value`, () => {
            codegen.if(`${r}.type`, () => {
                ctx.codegen.js(`size += ${r}.type.capacityEstimator()(${r}.data);`);
            }, () => {
                ctx.codegen.js(`size += maxEncodingCapacity(${r}.data);`);
            });
        }, () => {
            ctx.codegen.js(`size += maxEncodingCapacity(${r});`);
        });
    }
    random() {
        return json_random_1.RandomJson.generate({ nodeCount: 5 });
    }
    toTypeScriptAst() {
        return { node: 'AnyKeyword' };
    }
    toJtdForm() {
        const form = { nullable: true };
        return form;
    }
}
exports.AnyType = AnyType;
