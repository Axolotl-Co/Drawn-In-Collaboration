"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelApi = void 0;
const fanout_1 = require("thingies/es2020/fanout");
const nodes_1 = require("../../nodes");
const nodes_2 = require("./nodes");
const PatchBuilder_1 = require("../../../json-crdt-patch/PatchBuilder");
const fanout_2 = require("./fanout");
class ModelApi {
    constructor(model) {
        this.model = model;
        this.next = 0;
        this.onBeforeReset = new fanout_1.FanOut();
        this.onReset = new fanout_1.FanOut();
        this.onBeforePatch = new fanout_1.FanOut();
        this.onPatch = new fanout_1.FanOut();
        this.onBeforeLocalChange = new fanout_1.FanOut();
        this.onLocalChange = new fanout_1.FanOut();
        this.onLocalChanges = new fanout_2.MicrotaskBufferFanOut(this.onLocalChange);
        this.onBeforeTransaction = new fanout_1.FanOut();
        this.onTransaction = new fanout_1.FanOut();
        this.onChange = new fanout_2.MergeFanOut([this.onReset, this.onPatch, this.onLocalChange]);
        this.onChanges = new fanout_2.MicrotaskBufferFanOut(this.onChange);
        this.onFlush = new fanout_1.FanOut();
        this.stopAutoFlush = undefined;
        this.subscribe = (callback) => this.onChanges.listen(() => callback());
        this.getSnapshot = () => this.view();
        this.builder = new PatchBuilder_1.PatchBuilder(model.clock);
        model.onbeforereset = () => this.onBeforeReset.emit();
        model.onreset = () => this.onReset.emit();
        model.onbeforepatch = (patch) => this.onBeforePatch.emit(patch);
        model.onpatch = (patch) => this.onPatch.emit(patch);
    }
    wrap(node) {
        if (node instanceof nodes_1.ValNode)
            return node.api || (node.api = new nodes_2.ValApi(node, this));
        else if (node instanceof nodes_1.StrNode)
            return node.api || (node.api = new nodes_2.StrApi(node, this));
        else if (node instanceof nodes_1.BinNode)
            return node.api || (node.api = new nodes_2.BinApi(node, this));
        else if (node instanceof nodes_1.ArrNode)
            return node.api || (node.api = new nodes_2.ArrApi(node, this));
        else if (node instanceof nodes_1.ObjNode)
            return node.api || (node.api = new nodes_2.ObjApi(node, this));
        else if (node instanceof nodes_1.ConNode)
            return node.api || (node.api = new nodes_2.ConApi(node, this));
        else if (node instanceof nodes_1.VecNode)
            return node.api || (node.api = new nodes_2.VecApi(node, this));
        else
            throw new Error('UNKNOWN_NODE');
    }
    get r() {
        return new nodes_2.ValApi(this.model.root, this);
    }
    get node() {
        return this.r.get();
    }
    in(path) {
        return this.r.in(path);
    }
    find(path) {
        return this.node.find(path);
    }
    val(path) {
        return this.node.val(path);
    }
    vec(path) {
        return this.node.tup(path);
    }
    str(path) {
        return this.node.str(path);
    }
    bin(path) {
        return this.node.bin(path);
    }
    arr(path) {
        return this.node.arr(path);
    }
    obj(path) {
        return this.node.obj(path);
    }
    const(path) {
        return this.node.const(path);
    }
    root(json) {
        const builder = this.builder;
        builder.root(builder.json(json));
        this.apply();
        return this;
    }
    apply() {
        const ops = this.builder.patch.ops;
        const length = ops.length;
        const model = this.model;
        const from = this.next;
        this.onBeforeLocalChange.emit(from);
        for (let i = this.next; i < length; i++)
            model.applyOperation(ops[i]);
        this.next = length;
        model.tick++;
        this.onLocalChange.emit(from);
    }
    advance() {
        const from = this.next;
        this.next = this.builder.patch.ops.length;
        this.model.tick++;
        this.onLocalChange.emit(from);
    }
    view() {
        return this.model.view();
    }
    transaction(callback) {
        this.onBeforeTransaction.emit();
        callback();
        this.onTransaction.emit();
    }
    flush() {
        const patch = this.builder.flush();
        this.next = 0;
        this.onFlush.emit(patch);
        return patch;
    }
    autoFlush() {
        const drain = () => this.builder.patch.ops.length && this.flush();
        const onLocalChangesUnsubscribe = this.onLocalChanges.listen(drain);
        const onBeforeTransactionUnsubscribe = this.onBeforeTransaction.listen(drain);
        const onTransactionUnsubscribe = this.onTransaction.listen(drain);
        return (this.stopAutoFlush = () => {
            this.stopAutoFlush = undefined;
            onLocalChangesUnsubscribe();
            onBeforeTransactionUnsubscribe();
            onTransactionUnsubscribe();
        });
    }
}
exports.ModelApi = ModelApi;
