"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryStore = void 0;
const tslib_1 = require("tslib");
const json_crdt_1 = require("../../../json-crdt");
const json_crdt_patch_1 = require("../../../json-crdt-patch");
class MemoryStore {
    constructor() {
        this.blocks = new Map();
        this.patches = new Map();
    }
    get(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setImmediate(resolve));
            const block = this.blocks.get(id);
            if (!block)
                return;
            return { block };
        });
    }
    create(id, patches) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setImmediate(resolve));
            if (!Array.isArray(patches))
                throw new Error('NO_PATCHES');
            if (this.blocks.has(id))
                throw new Error('BLOCK_EXISTS');
            const model = json_crdt_1.Model.withLogicalClock();
            let seq = -1;
            const now = Date.now();
            if (patches.length) {
                for (const patch of patches) {
                    seq++;
                    if (seq !== patch.seq)
                        throw new Error('PATCHES_OUT_OF_ORDER');
                    model.applyPatch(json_crdt_patch_1.Patch.fromBinary(patch.blob));
                    if (patch.created > now)
                        patch.created = now;
                }
            }
            const block = {
                id,
                seq: seq,
                blob: model.toBinary(),
                created: now,
                updated: now,
            };
            this.blocks.set(id, block);
            this.patches.set(id, patches);
            return { block };
        });
    }
    edit(id, patches) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setImmediate(resolve));
            if (!Array.isArray(patches) || !patches.length)
                throw new Error('NO_PATCHES');
            const block = this.blocks.get(id);
            const existingPatches = this.patches.get(id);
            if (!block || !existingPatches)
                throw new Error('BLOCK_NOT_FOUND');
            let seq = patches[0].seq;
            const diff = seq - block.seq - 1;
            if (block.seq + 1 < seq)
                throw new Error('PATCH_SEQ_TOO_HIGH');
            const model = json_crdt_1.Model.fromBinary(block.blob);
            for (const patch of patches) {
                if (seq !== patch.seq)
                    throw new Error('PATCHES_OUT_OF_ORDER');
                model.applyPatch(json_crdt_patch_1.Patch.fromBinary(patch.blob));
                patch.seq -= diff;
                seq++;
            }
            block.seq += patches.length;
            block.blob = model.toBinary();
            block.updated = Date.now();
            for (const patch of patches)
                existingPatches.push(patch);
            return { block };
        });
    }
    history(id, min, max) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setImmediate(resolve));
            const patches = this.patches.get(id);
            if (!patches)
                return [];
            return patches.slice(min, max + 1);
        });
    }
    remove(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setImmediate(resolve));
            this.removeSync(id);
        });
    }
    removeSync(id) {
        this.blocks.delete(id);
        this.patches.delete(id);
    }
    stats() {
        return {
            blocks: this.blocks.size,
            patches: [...this.patches.values()].reduce((acc, v) => acc + v.length, 0),
        };
    }
    removeOlderThan(ts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setImmediate(resolve));
            for (const [id, block] of this.blocks)
                if (block.created < ts)
                    this.removeSync(id);
        });
    }
}
exports.MemoryStore = MemoryStore;
