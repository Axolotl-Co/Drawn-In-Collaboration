"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlocksServices = void 0;
const tslib_1 = require("tslib");
const MemoryStore_1 = require("./MemoryStore");
const caller_1 = require("../../../reactive-rpc/common/rpc/caller");
const BLOCK_TTL = 1000 * 60 * 60;
const validatePatches = (patches) => {
    for (const patch of patches) {
        if (patch.blob.length > 2000)
            throw caller_1.RpcError.validation('patch blob too large');
        if (patch.seq > 500000)
            throw caller_1.RpcError.validation('patch seq too large');
    }
};
class BlocksServices {
    constructor(services) {
        this.services = services;
        this.store = new MemoryStore_1.MemoryStore();
    }
    create(id, patches) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.maybeGc();
            const { store } = this;
            validatePatches(patches);
            const { block } = yield store.create(id, patches);
            const data = {
                block,
                patches,
            };
            this.services.pubsub.publish(`__block:${id}`, data).catch((error) => {
                console.error('Error publishing block patches', error);
            });
            return { block };
        });
    }
    get(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { store } = this;
            const result = yield store.get(id);
            if (!result)
                throw caller_1.RpcError.fromCode(caller_1.RpcErrorCodes.NOT_FOUND);
            const patches = yield store.history(id, 0, result.block.seq);
            const { block } = result;
            return { block, patches };
        });
    }
    remove(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.store.remove(id);
            this.services.pubsub.publish(`__block:${id}`, { deleted: true }).catch((error) => {
                console.error('Error publishing block deletion', error);
            });
        });
    }
    history(id, min, max) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { store } = this;
            const patches = yield store.history(id, min, max);
            return { patches };
        });
    }
    edit(id, patches) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.maybeGc();
            if (!Array.isArray(patches))
                throw caller_1.RpcError.validation('patches must be an array');
            if (!patches.length)
                throw caller_1.RpcError.validation('patches must not be empty');
            const seq = patches[0].seq;
            const { store } = this;
            validatePatches(patches);
            const { block } = yield store.edit(id, patches);
            this.services.pubsub.publish(`__block:${id}`, { patches }).catch((error) => {
                console.error('Error publishing block patches', error);
            });
            const expectedBlockSeq = seq + patches.length - 1;
            const hadConcurrentEdits = block.seq !== expectedBlockSeq;
            let patchesBack = [];
            if (hadConcurrentEdits) {
                patchesBack = yield store.history(id, seq, block.seq);
            }
            return {
                block,
                patches: patchesBack,
            };
        });
    }
    stats() {
        return this.store.stats();
    }
    maybeGc() {
        if (Math.random() < 0.05)
            this.gc().catch((error) => {
                console.error('Error running gc', error);
            });
    }
    gc() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ts = Date.now() - BLOCK_TTL;
            const { store } = this;
            yield store.removeOlderThan(ts);
        });
    }
}
exports.BlocksServices = BlocksServices;
