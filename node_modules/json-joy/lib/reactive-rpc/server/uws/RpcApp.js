"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcApp = void 0;
const tslib_1 = require("tslib");
const util_1 = require("./util");
const router_1 = require("../../../util/router");
const RpcMessageBatchProcessor_1 = require("../../common/rpc/RpcMessageBatchProcessor");
const error_1 = require("../../common/rpc/caller/error");
const context_1 = require("../context");
const RpcMessageCodecs_1 = require("../../common/codec/RpcMessageCodecs");
const Value_1 = require("../../common/messages/Value");
const RpcCodecs_1 = require("../../common/codec/RpcCodecs");
const Codecs_1 = require("../../../json-pack/codecs/Codecs");
const Writer_1 = require("../../../util/buffers/Writer");
const copy_1 = require("../../../util/buffers/copy");
const common_1 = require("../../common");
const HDR_BAD_REQUEST = Buffer.from('400 Bad Request', 'utf8');
const HDR_NOT_FOUND = Buffer.from('404 Not Found', 'utf8');
const ERR_NOT_FOUND = error_1.RpcError.fromCode(error_1.RpcErrorCodes.NOT_FOUND, 'Not Found');
const noop = (x) => { };
class RpcApp {
    constructor(options) {
        var _a, _b;
        this.options = options;
        this.router = new router_1.Router();
        this.app = options.uws;
        (this.maxRequestBodySize = (_a = options.maxRequestBodySize) !== null && _a !== void 0 ? _a : 1024 * 1024),
            (this.codecs = new RpcCodecs_1.RpcCodecs((_b = options.codecs) !== null && _b !== void 0 ? _b : new Codecs_1.Codecs(new Writer_1.Writer()), new RpcMessageCodecs_1.RpcMessageCodecs()));
        this.batchProcessor = new RpcMessageBatchProcessor_1.RpcMessageBatchProcessor({ caller: options.caller });
    }
    enableCors() {
        (0, util_1.enableCors)(this.options.uws);
    }
    routeRaw(method, path, handler) {
        method = method.toLowerCase();
        this.router.add(method + path, handler);
    }
    route(method, path, handler) {
        this.routeRaw(method, path, (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = yield handler(ctx);
            const res = ctx.res;
            if (res.aborted)
                return;
            const codec = ctx.resCodec;
            const encoder = codec.encoder;
            const writer = encoder.writer;
            writer.reset();
            if (res instanceof Value_1.RpcValue) {
                if (res.type)
                    res.type.encoder(codec.format)(res.data, encoder);
                else
                    encoder.writeAny(res.data);
            }
            else {
                encoder.writeAny(result);
            }
            if (res.aborted)
                return;
            ctx.sendResponse(writer.flush());
        }));
    }
    enableHttpPing(path = '/ping') {
        this.route('GET', path, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return 'pong';
        }));
        return this;
    }
    enableHttpRpc(path = '/rpc') {
        this.routeRaw('POST', path, (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const res = ctx.res;
                const bodyUint8 = yield ctx.requestBody(this.maxRequestBodySize);
                if (res.aborted)
                    return;
                const messageCodec = ctx.msgCodec;
                const incomingMessages = messageCodec.decodeBatch(ctx.reqCodec, bodyUint8);
                try {
                    const outgoingMessages = yield this.batchProcessor.onBatch(incomingMessages, ctx);
                    if (res.aborted)
                        return;
                    const resCodec = ctx.resCodec;
                    messageCodec.encodeBatch(resCodec, outgoingMessages);
                    const buf = resCodec.encoder.writer.flush();
                    if (res.aborted)
                        return;
                    res.end(buf);
                }
                catch (error) {
                    const logger = (_a = this.options.logger) !== null && _a !== void 0 ? _a : console;
                    logger.error('HTTP_RPC_PROCESSING', error, { messages: incomingMessages });
                    throw error_1.RpcError.internal(error);
                }
            }
            catch (error) {
                if (typeof error === 'object' && error)
                    if (error.message === 'Invalid JSON')
                        throw error_1.RpcError.badRequest();
                throw error_1.RpcError.from(error);
            }
        }));
        return this;
    }
    enableWsRpc(path = '/rpc') {
        var _a, _b;
        const maxBackpressure = 4 * 1024 * 1024;
        const augmentContext = (_a = this.options.augmentContext) !== null && _a !== void 0 ? _a : noop;
        const options = this.options;
        const logger = (_b = options.logger) !== null && _b !== void 0 ? _b : console;
        const caller = options.caller;
        this.app.ws(path, {
            idleTimeout: 0,
            maxPayloadLength: 4 * 1024 * 1024,
            upgrade: (res, req, context) => {
                const secWebSocketKey = req.getHeader('sec-websocket-key');
                const secWebSocketProtocol = req.getHeader('sec-websocket-protocol');
                const secWebSocketExtensions = req.getHeader('sec-websocket-extensions');
                const ctx = context_1.ConnectionContext.fromWs(req, res, secWebSocketProtocol, null, this);
                augmentContext(ctx);
                res.upgrade({ ctx }, secWebSocketKey, secWebSocketProtocol, secWebSocketExtensions, context);
            },
            open: (ws_) => {
                try {
                    const ws = ws_;
                    const ctx = ws.ctx;
                    const resCodec = ctx.resCodec;
                    const msgCodec = ctx.msgCodec;
                    const encoder = resCodec.encoder;
                    ws.rpc = new common_1.RpcMessageStreamProcessor({
                        caller,
                        send: (messages) => {
                            try {
                                if (ws.getBufferedAmount() > maxBackpressure)
                                    return;
                                const writer = encoder.writer;
                                writer.reset();
                                msgCodec.encodeBatch(resCodec, messages);
                                const encoded = writer.flush();
                                ws.send(encoded, true, false);
                            }
                            catch (error) {
                                logger.error('WS_SEND', error, { messages });
                            }
                        },
                        bufferSize: 1,
                        bufferTime: 0,
                    });
                }
                catch (error) {
                    logger.error('RX_WS_OPEN', error);
                }
            },
            message: (ws_, buf, isBinary) => {
                try {
                    const ws = ws_;
                    const ctx = ws.ctx;
                    const reqCodec = ctx.reqCodec;
                    const msgCodec = ctx.msgCodec;
                    const uint8 = (0, copy_1.copy)(new Uint8Array(buf));
                    const rpc = ws.rpc;
                    try {
                        const messages = msgCodec.decodeBatch(reqCodec, uint8);
                        try {
                            rpc.onMessages(messages, ctx);
                        }
                        catch (error) {
                            logger.error('RX_RPC_PROCESSING', error, messages);
                            return;
                        }
                    }
                    catch (error) {
                        logger.error('RX_RPC_DECODING', error, { codec: reqCodec.id, buf: Buffer.from(uint8).toString() });
                    }
                }
                catch (error) {
                    logger.error('RX_WS_MESSAGE', error);
                }
            },
            close: (ws_, code, message) => {
                const ws = ws_;
                ws.rpc.stop();
            },
        });
        return this;
    }
    startRouting() {
        var _a, _b;
        const matcher = this.router.compile();
        const codecs = this.codecs;
        let responseCodec = codecs.value.json;
        const options = this.options;
        const augmentContext = (_a = options.augmentContext) !== null && _a !== void 0 ? _a : noop;
        const logger = (_b = options.logger) !== null && _b !== void 0 ? _b : console;
        this.app.any('/*', (res, req) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _c;
            try {
                res.onAborted(() => {
                    res.aborted = true;
                });
                const method = req.getMethod();
                const url = req.getUrl();
                try {
                    const match = matcher(method + url);
                    if (!match) {
                        res.cork(() => {
                            res.writeStatus(HDR_NOT_FOUND);
                            res.end(error_1.RpcErrorType.encode(responseCodec, ERR_NOT_FOUND));
                        });
                        return;
                    }
                    const handler = match.data;
                    const params = match.params;
                    const ctx = context_1.ConnectionContext.fromReqRes(req, res, params, this);
                    responseCodec = ctx.resCodec;
                    augmentContext(ctx);
                    yield handler(ctx);
                }
                catch (err) {
                    if (err instanceof Value_1.RpcValue)
                        err = err.data;
                    if (!(err instanceof error_1.RpcError))
                        err = error_1.RpcError.from(err);
                    const error = err;
                    if (error.errno === error_1.RpcErrorCodes.INTERNAL_ERROR) {
                        logger.error('UWS_ROUTER_INTERNAL_ERROR', error, { originalError: (_c = error.originalError) !== null && _c !== void 0 ? _c : null });
                    }
                    res.cork(() => {
                        res.writeStatus(HDR_BAD_REQUEST);
                        res.end(error_1.RpcErrorType.encode(responseCodec, error));
                    });
                }
            }
            catch (_d) { }
        }));
    }
    startWithDefaults() {
        var _a, _b, _c, _d;
        this.enableCors();
        this.enableHttpPing();
        this.enableHttpRpc();
        this.enableWsRpc();
        this.startRouting();
        const options = this.options;
        const port = (_a = options.port) !== null && _a !== void 0 ? _a : +(process.env.PORT || 9999);
        const host = (_c = (_b = options.host) !== null && _b !== void 0 ? _b : process.env.HOST) !== null && _c !== void 0 ? _c : '0.0.0.0';
        const logger = (_d = options.logger) !== null && _d !== void 0 ? _d : console;
        this.options.uws.listen(host, port, (token) => {
            if (token) {
                logger.log({ msg: 'SERVER_STARTED', url: `http://localhost:${port}` });
            }
            else {
                logger.error('SERVER_START', new Error(`Failed to listen on ${port} port.`));
            }
        });
    }
}
exports.RpcApp = RpcApp;
