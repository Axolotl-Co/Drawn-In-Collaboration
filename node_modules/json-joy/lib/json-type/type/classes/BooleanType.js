"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BooleanType = void 0;
const json_random_1 = require("../../../json-random");
const validate_1 = require("../../schema/validate");
const constants_1 = require("../../constants");
const AbstractType_1 = require("./AbstractType");
class BooleanType extends AbstractType_1.AbstractType {
    constructor(schema) {
        super();
        this.schema = schema;
    }
    toJsonSchema(ctx) {
        return Object.assign({ type: 'boolean' }, super.toJsonSchema(ctx));
    }
    validateSchema() {
        (0, validate_1.validateTType)(this.getSchema(), 'bool');
    }
    codegenValidator(ctx, path, r) {
        const err = ctx.err(constants_1.ValidationError.BOOL, path);
        ctx.js(`if(typeof ${r} !== "boolean") return ${err};`);
        ctx.emitCustomValidators(this, path, r);
    }
    codegenJsonTextEncoder(ctx, value) {
        ctx.js(`s += ${value.use()} ? 'true' : 'false';`);
    }
    codegenBinaryEncoder(ctx, value) {
        ctx.js(`encoder.writeBoolean(${value.use()});`);
    }
    codegenCborEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenMessagePackEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenJsonEncoder(ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    }
    codegenCapacityEstimator(ctx, value) {
        ctx.inc(5);
    }
    random() {
        return json_random_1.RandomJson.genBoolean();
    }
    toTypeScriptAst() {
        return { node: 'BooleanKeyword' };
    }
    toJson(value, system = this.system) {
        return (value ? 'true' : 'false');
    }
    toJtdForm() {
        const form = { type: 'boolean' };
        return form;
    }
}
exports.BooleanType = BooleanType;
